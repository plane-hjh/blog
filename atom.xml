<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>plane&#39;s blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/blog/"/>
  <updated>2020-03-24T22:43:38.547Z</updated>
  <id>http://yoursite.com/blog/</id>
  
  <author>
    <name>hejianhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Js各种源码实现</title>
    <link href="http://yoursite.com/blog/2020/03/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E7%A7%98%E7%B1%8D/"/>
    <id>http://yoursite.com/blog/2020/03/24/前端面试-手写代码秘籍/</id>
    <published>2020-03-23T22:12:09.000Z</published>
    <updated>2020-03-24T22:43:38.547Z</updated>
    
    <content type="html"><![CDATA[<p>在面试中，面试官多多少少都会要求面试者手写几道手写代码方法，这时候，不仅要求面试者能够熟练使用用这个方法，更是要求面试者对这个方法的原理。</p><ul><li><p>实现一个 new 操作符</p></li><li><p>实现一个 instanceof</p></li><li><p>实现一个浅拷贝或者深拷贝</p></li><li><p>实现 call 和 apply</p></li><li><p>实现 防抖 和 节流</p></li><li><p>实现一个 promise</p></li></ul><a id="more"></a><h2 id="实现一个-new-操作符"><a href="#实现一个-new-操作符" class="headerlink" title="实现一个 new 操作符"></a>实现一个 new 操作符</h2><p>要创建一个实例，那么必须要使用 <code>new</code> 操作符。使用 <code>new</code> 操作符内部会经历4个过程</p><ol><li><p>创建一个新的对象</p></li><li><p>将构造函数的作用域赋给了新对象</p></li><li><p>执行构造函数中的代码</p></li><li><p>返回新的对象<strong><em>（注意：如果构造函数中有返回对象类型的值，那么我们就直接返回这个对象。否则返回新的对象）</em></strong></p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNew</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个新的对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将构造函数的作用域赋给了新对象</span></span><br><span class="line">    <span class="keyword">if</span>(fn.prototype) &#123;</span><br><span class="line">        obj.__proto__ = fn.prototype</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 执行构造函数中的代码</span></span><br><span class="line">    <span class="keyword">const</span> result = fn.apply(obj, [...arguments].slice(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 返回新的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个-instanceof"><a href="#实现一个-instanceof" class="headerlink" title="实现一个 instanceof"></a>实现一个 instanceof</h2><p><code>instanceof</code> 可以正确的判断对象的类型。因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// letf 对象</span></span><br><span class="line"><span class="comment">// right 类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">instanceof</span> = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 类型的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象的原型</span></span><br><span class="line">    <span class="keyword">let</span> proto = left.__proto__</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(proto === prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        proto = proto.__proto__</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个浅拷贝或者深拷贝"><a href="#实现一个浅拷贝或者深拷贝" class="headerlink" title="实现一个浅拷贝或者深拷贝"></a>实现一个浅拷贝或者深拷贝</h2><p>在使用对象的时候，我们经常会碰到这样的一个问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    name: <span class="string">'xiaohong'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = a</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">'xiaoming'</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// &#123;name: 'xiaoming'&#125;</span></span><br></pre></td></tr></table></figure><p>可能会有朋友会问，咦，我们不是没有修改对象 <code>b</code> 的属性吗，怎么属性 <code>name</code> 变了。其实这里面涉及到引用类型的问题。对象是属于引用类型，把对象赋值给另外一个变量，实际上是把对象的指针指向的内存地址共享给了变量。对象和变量共享同一份内存地址。那么 <code>a</code> 的属性改变了，那么 <code>b</code> 的也会跟着变化的。这时候为了避免这种情况发生，我们可以使用 <code>浅拷贝</code> 来进行操作</p><ul><li>Object.assign</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    name: <span class="string">'xiaohong'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">'xiaoming'</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// &#123;name: 'xiaohong'&#125;</span></span><br></pre></td></tr></table></figure><ul><li>对象展开运算符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    name: <span class="string">'xiaohong'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;...a&#125;</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">'xiaoming'</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// &#123;name: 'xiaohong'&#125;</span></span><br></pre></td></tr></table></figure><p>注意，<code>浅拷贝</code> 避免对象内部的属性不是引用类型的情况，那么如果对象的内部属性仍然是引用类型的情况时，<code>浅拷贝</code> 这时候只会对对象最外层生效了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    name: <span class="string">'xiaohong'</span>,</span><br><span class="line">    obj: &#123;</span><br><span class="line">        age: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line"></span><br><span class="line">a.obj.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// &#123;name: 'xiaohong',obj:&#123;age: 20&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入 <code>深拷贝</code> 的概念了。</p><p>一般来说，使用 <code>JSON.parse(JSON.stringify())</code> 已经满足了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify( someObj ) );</span><br></pre></td></tr></table></figure><p>但是这种方法存在局限性</p><ul><li>会忽略 undefined</li><li>会忽略 symbol</li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><p>所以，我们可以利用递归来解决这种情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是简单数据类型，</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj == <span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="comment">//复杂数据类型</span></span><br><span class="line">        <span class="keyword">var</span> result = obj.constructor == <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            result[i] = <span class="keyword">typeof</span> obj[i] == <span class="string">"object"</span> ? deepCopy(obj[i]) : obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//简单数据类型 直接 == 赋值</span></span><br><span class="line">        <span class="keyword">var</span> result = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-call-和-apply"><a href="#实现-call-和-apply" class="headerlink" title="实现 call 和 apply"></a>实现 call 和 apply</h2><p><code>call</code> 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。与 <code>apply</code> 方法类似，只有一个区别，就是 <code>call</code> 方法接受的是一个参数列表，而 <code>apply</code> 方法接受的是一个包含多个参数的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Fuction.prototype.myCall = <span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span><br><span class="line">    content = content || <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line">    content.fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> res = content.fn(...args)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> content.fn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，<code>apply</code> 的实现只是传入的参数是一个数组而已</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Fuction.prototype.myApply = <span class="function">(<span class="params">content</span>) =&gt;</span> &#123;</span><br><span class="line">    content = content || <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line">    content.fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res</span><br><span class="line">    <span class="keyword">if</span>(argument[<span class="number">1</span>]) &#123;</span><br><span class="line">        res = content.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = content.fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> content.fn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-防抖-和-节流"><a href="#实现-防抖-和-节流" class="headerlink" title="实现 防抖 和 节流"></a>实现 防抖 和 节流</h2><p><code>防抖</code> 指的是防止用户用户过多操作，而带来不必要的性能耗费，把操作改成最后一次执行，只要用户有操作，事件行为也会一直被推迟。例如输入框</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">wait, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果事件一直在触发，那么就把上一次事件的定时器清除</span></span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            clearTimeOut(timer)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>防抖</code> 和 <code>节流</code> 本质是不一样的。<code>防抖</code> 是将多次执行变为最后一次执行，<code>节流</code> 是将多次执行变成每隔一段时间执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">wait, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> preTime = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前的时间戳</span></span><br><span class="line">        <span class="keyword">let</span> curTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与上一个时间段的时间戳做对比</span></span><br><span class="line">        <span class="keyword">if</span>((curTime - preTime) &gt; wait) &#123;</span><br><span class="line">            preTime = curTime</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个promise"><a href="#实现一个promise" class="headerlink" title="实现一个promise"></a>实现一个promise</h2><p>（1）”promise”是一个对象或者函数，该对象或者函数有一个then方法</p><p>（2）”then”是一个对象或者函数，用来定义then方法</p><p>（3）”value”是promise状态成功时的值</p><p>（4）”reason”是promise状态失败时的值</p><p>普通版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个promise必须有3个状态，pending，fulfilled(resolved)</span></span><br><span class="line">    self.status = <span class="string">"pending"</span> <span class="comment">// 定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>  <span class="comment">// 定义状态为resolve的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span> <span class="comment">// 定义状态为reject的时候的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 两个pending，保证了状态的改变是不可逆的</span></span><br><span class="line">        <span class="keyword">if</span>(selft.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            self.value = value</span><br><span class="line">            self.status = <span class="string">"resolved"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 两个pending，保证了状态的改变是不可逆的</span></span><br><span class="line">        <span class="keyword">if</span>(selft.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = <span class="string">"rejectd"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(resolve, reject)</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个promise必须有一个then方法，then方法接受两个参数</span></span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFullfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(self.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"resolved"</span>:</span><br><span class="line">            onFullfilled(self.value)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rejected"</span>:</span><br><span class="line">            onRejected(self.value)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里 <code>myPromise</code> 无法处理异步的 <code>resolve</code>. 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p= <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而且 <code>myPromise</code> 也没有实现链式调用，也就是说 <code>then</code> 方法返回的应该是一个 <code>promise</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了处理异步resolve，我们修改myPromise的定义，用2个数组onFullfilledArray和onRejectedArray来保存异步的方法。在状态发生改变时，一次遍历执行数组中的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self=<span class="keyword">this</span>;</span><br><span class="line">    self.status=<span class="string">"pending"</span> <span class="comment">//定义状态改变前的初始状态</span></span><br><span class="line">    self.value=<span class="literal">undefined</span>;<span class="comment">//定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason=<span class="literal">undefined</span>;<span class="comment">//定义状态为rejected的时候的状态</span></span><br><span class="line">    self.onFullfilledArray=[];</span><br><span class="line">    self.onRejectedArray=[];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(self.status===<span class="string">"pending"</span>)&#123;</span><br><span class="line">          self.value=value;</span><br><span class="line">          self.status=<span class="string">"resolved"</span>;</span><br><span class="line">          self.onFullfilledArray.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">                f(self.value);</span><br><span class="line">                <span class="comment">//如果状态从pending变为resolved，</span></span><br><span class="line">                <span class="comment">//那么就遍历执行里面的异步方法</span></span><br><span class="line">          &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(self.status===<span class="string">"pending"</span>)&#123;</span><br><span class="line">          self.reason=reason;</span><br><span class="line">          self.status=<span class="string">"rejected"</span>;</span><br><span class="line">          self.onRejectedArray.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">              f(self.reason);</span><br><span class="line">             <span class="comment">//如果状态从pending变为rejected， </span></span><br><span class="line">             <span class="comment">//那么就遍历执行里面的异步方法</span></span><br><span class="line">          &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="keyword">constructor</span>(resolve,reject);</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">       reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要通过then方法实现链式调用，那么也就是说then方法每次调用需要返回一个primise,同时在返回promise的构造体里面，增加错误处理部分，我们来改造then方法</span></span><br><span class="line">myPromise.prototype.then=<span class="function"><span class="keyword">function</span>(<span class="params">onFullfilled,onRejected</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self=<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> promise2;</span><br><span class="line">    <span class="keyword">switch</span>(self.status)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"pending"</span>:</span><br><span class="line">        promise2=<span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">             self.onFullfilledArray.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                   <span class="keyword">let</span> temple=onFullfilled(self.value);</span><br><span class="line">                   resolve(temple)</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                   reject(e) <span class="comment">//error catch</span></span><br><span class="line">                &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">             self.onRejectedArray.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                 <span class="keyword">try</span>&#123;</span><br><span class="line">                   <span class="keyword">let</span> temple=onRejected(self.reason);</span><br><span class="line">                   reject(temple)</span><br><span class="line">                 &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                   reject(e)<span class="comment">// error catch</span></span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"resolved"</span>:</span><br><span class="line">        promise2=<span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">              <span class="keyword">let</span> temple=onFullfilled(self.value);</span><br><span class="line">              <span class="comment">//将上次一then里面的方法传递进下一个Promise的状态</span></span><br><span class="line">              resolve(temple);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">              reject(e);<span class="comment">//error catch</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"rejected"</span>:</span><br><span class="line">        promise2=<span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">let</span> temple=onRejected(self.reason);</span><br><span class="line">               <span class="comment">//将then里面的方法传递到下一个Promise的状态里</span></span><br><span class="line">               resolve(temple);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">               reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试中，面试官多多少少都会要求面试者手写几道手写代码方法，这时候，不仅要求面试者能够熟练使用用这个方法，更是要求面试者对这个方法的原理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实现一个 new 操作符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现一个 instanceof&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现一个浅拷贝或者深拷贝&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现 call 和 apply&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现 防抖 和 节流&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现一个 promise&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/blog/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-斐波那契数列</title>
    <link href="http://yoursite.com/blog/2020/03/22/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://yoursite.com/blog/2020/03/22/剑指offer-javascript版-斐波那契数列/</id>
    <published>2020-03-22T08:45:12.000Z</published>
    <updated>2020-03-22T09:08:42.672Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong>：写一个函数，输入n，求斐波那契数列的第n项。斐波那契数列的定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1.</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，输入n，求斐波那契数列的第n项。斐波那契数列的定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>,   F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(N) = F(N - <span class="number">1</span>) + F(N - <span class="number">2</span>), 其中 N &gt; <span class="number">1.</span></span><br></pre></td></tr></table></figure><h2 id="解法一，递归"><a href="#解法一，递归" class="headerlink" title="解法一，递归"></a>解法一，递归</h2><p>由题目描述可以知道，斐波那契数列的第一项是 <code>0</code>，第一项是 <code>1</code> ，第 <code>n</code> 项是第 <code>n-1</code> 和第 <code>n-2</code>的和，那么我们就可以下手了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">const</span> fib = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二，递归-备忘录"><a href="#解法二，递归-备忘录" class="headerlink" title="解法二，递归+备忘录"></a>解法二，递归+备忘录</h2><p>使用递归来解这道题可以说是相当简单了，但是有时候面试官并不想看到我们单纯的使用递归去解这一道题，因为计算量太多重复的了。例如我们在计算 <code>n=9</code> 的时候。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">9</span>) = f(<span class="number">8</span>) + f(<span class="number">7</span>)</span><br><span class="line">那么</span><br><span class="line">f(<span class="number">8</span>) = f(<span class="number">7</span>) + f(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>可以知道<code>f(7)</code> 被计算了两次，以此类推可以知道，我们在计算 <code>f(9)</code> 的时候，重复了太多了计算量了。那么我们可以使用 <code>备忘录</code> 的解法把已经计算过的值保存下来，下次如果再计算相同的值的时候，直接从备忘录里面取就可以了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在动态规划的一种做法中，可以借助“备忘录”来实现结果的缓存，避免重复计算</span></span><br><span class="line"><span class="keyword">const</span> fib = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="keyword">const</span> cache = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache[n] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache[n] = Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> cache[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解法三，循环-备忘录"><a href="#解法三，循环-备忘录" class="headerlink" title="解法三，循环+备忘录"></a>解法三，循环+备忘录</h2><p>我们也可以使用循环来替代递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fib = <span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="keyword">const</span> cache = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cache[n]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> fibNone = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> fibNtwo = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> fibN = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fibN = fibNone + fibNtwo</span><br><span class="line"></span><br><span class="line">        fibNtwo = fibNone</span><br><span class="line">        fibNone = fibN</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fibN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>类似题目：</p><ul><li>青蛙跳台阶问题</li></ul><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：写一个函数，输入n，求斐波那契数列的第n项。斐波那契数列的定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;F(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,   F(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;F(N) = F(N - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) + F(N - &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), 其中 N &amp;gt; &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="递归" scheme="http://yoursite.com/blog/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-用两个栈实现队列</title>
    <link href="http://yoursite.com/blog/2020/03/22/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/blog/2020/03/22/剑指offer-javascript版-用两个栈实现队列/</id>
    <published>2020-03-22T08:33:29.000Z</published>
    <updated>2020-03-22T08:44:18.199Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong>：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"CQueue"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">输出：[<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><p>示例 2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"CQueue"</span>,<span class="string">"deleteHead"</span>,<span class="string">"appendTail"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[<span class="literal">null</span>,<span class="number">-1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例 1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"CQueue"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]</span><br><span class="line">[[],[<span class="number">3</span>],[],[]]</span><br><span class="line">输出：[<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"CQueue"</span>,<span class="string">"deleteHead"</span>,<span class="string">"appendTail"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[<span class="literal">null</span>,<span class="number">-1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * outStack 不为空：弹出元素</span></span><br><span class="line"><span class="comment"> * outStack 为空：将 inStack 元素依次弹出，放入到 outStack 中（在数据转移过程中，顺序已经从后入先出变成了先入先出）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> CQueue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.inStack = []</span><br><span class="line">    <span class="keyword">this</span>.outStack = []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CQueue.prototype.appendTail = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.inStack.push(value)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CQueue.prototype.deleteHead = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; inStack, outStack&#125; = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要出的栈内没有元素，那么直接先把入栈内的元素，添加到出栈。然后再删除</span></span><br><span class="line">    <span class="keyword">if</span>(!outStack.length) &#123;</span><br><span class="line">        <span class="keyword">while</span>(inStack.length) &#123;</span><br><span class="line">            outStack.push(inStack.pop())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outStack.pop() || <span class="number">-1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;string&quot;&gt;&quot;CQueue&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;appendTail&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;deleteHead&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;deleteHead&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[],[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],[],[]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/blog/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="http://yoursite.com/blog/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-二叉树的下一个节点</title>
    <link href="http://yoursite.com/blog/2020/03/22/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/blog/2020/03/22/剑指offer-javascript版-二叉树的下一个节点/</id>
    <published>2020-03-22T08:15:03.000Z</published>
    <updated>2020-03-22T08:23:39.974Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong>：给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左，右子节点的指针，还有一个指向父节点的指针</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左，右子节点的指针，还有一个指向父节点的指针&lt;/p&gt;

      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>树</title>
    <link href="http://yoursite.com/blog/2020/03/21/%E6%A0%91/"/>
    <id>http://yoursite.com/blog/2020/03/21/树/</id>
    <published>2020-03-21T09:08:04.000Z</published>
    <updated>2020-03-22T06:13:15.107Z</updated>
    
    <content type="html"><![CDATA[<p>想普及一下树的知识，个人认为树是算法必须要牢牢掌握的一部分。</p><p>一般树的逻辑可以说是灰常滴简单了：</p><ul><li><p>除根节点之外的每个节点只有一个父节点，根节点没有父节点。</p></li><li><p>除叶节点之外所有节点都有一个或多个子节点，叶节点没有子节点。</p></li></ul><p>父节点和子节点之间是用指针连接，所以树会涉及到大量的指针，因此与树有关的面试题都不太容易，但是越不容易的知识点，我们就越要攻克。</p><a id="more"></a><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>但是面试时候提到的树，大部分都是二叉树。二叉树是树的一种特殊结构，在二叉树中每个节点最多只能有两个子节点。在二叉树中最重要的考点莫过于树的遍历，即按照某一个顺序遍历访问树中的所有节点。</p><p>二叉树的遍历可以有以下几种：</p><ul><li><p>前序遍历</p></li><li><p>中序遍历</p></li><li><p>后序遍历</p></li><li><p>层序遍历</p></li></ul><p>但是从更宏观的角度来说，也可以归结为两大类</p><ul><li><p>深度优先遍历（前序遍历，中序遍历，后序遍历）</p></li><li><p>广度优先遍历（层序遍历）</p></li></ul><p>深度优先遍历和层次优先遍历这两个概念可不局限于二叉树，更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树，图，或其他一些复杂数据结构时，这两个概念常常被使用到。</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方 式。即先访问树的根节点，再访问根节点的子节点，先往深层访问，深层访问节点结束了，再返回访问同层节点，之后再继续往深层访问节点…可能这种说法有些抽象，下面就通过二叉树的前序遍历、中序遍 历、后序遍历 ，来看一看深度优先是怎么回事吧。</p><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><ul><li><code>前序遍历</code>：先访问根节点，再访问左节点，最后访问右节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="keyword">const</span> preOrderTraverse = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> preOrder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 先访问根节点</span></span><br><span class="line">            list.push(node.val)</span><br><span class="line">            <span class="comment">// 再访问左节点</span></span><br><span class="line">            preOrder(node.left)</span><br><span class="line">            <span class="comment">// 最后访问右节点</span></span><br><span class="line">            preOrder(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归版本</span></span><br><span class="line"><span class="keyword">const</span> preOrderTraverseUnRecur = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> curNode = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> left = curNode.left</span><br><span class="line">        <span class="keyword">const</span> right = curNode.right</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步的时候，先访问的是根节点</span></span><br><span class="line">        list.push(curNode.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right) &#123;</span><br><span class="line">            stack.push(right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为pop是取出最后一个元素，所以我们要确保首先拿到的是左节点</span></span><br><span class="line">        <span class="keyword">if</span>(left) &#123;</span><br><span class="line">            stack.push(left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul><li><code>中序遍历</code>：先访问左节点，再访问中节点，最后访问右节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="keyword">const</span> inOrderTraverse = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> inOrder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            inOrder(node.left)</span><br><span class="line">            list.push(node.val)</span><br><span class="line">            inOrder(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归版本</span></span><br><span class="line"><span class="keyword">const</span> inOrderTraverseUnRecur = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="comment">// 借助了栈，先进后出的概念</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> head = root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length !== <span class="number">0</span> || head !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            stack.push(head)</span><br><span class="line">            head = head.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            head = stack.pop()</span><br><span class="line">            list.push(head.val)</span><br><span class="line">            head = head.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul><li><code>后序遍历</code>：先访问左节点，再访问右节点，最后访问根节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">const</span> postOrderTraverse = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> postOrder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">            postOrder(node.left)</span><br><span class="line">            postOrder(node.right)</span><br><span class="line">            list.push(node.val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postOrder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="keyword">const</span> postOrderTraverseUnRecur = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="keyword">if</span>(root !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> s1 = []</span><br><span class="line">        <span class="keyword">let</span> s2 = []</span><br><span class="line"></span><br><span class="line">        s1.push(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(s1.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            head = s1.pop()</span><br><span class="line">            s2.push(head)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head.left !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                s1.push(head.left)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head.right !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                s1.push(head.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(s2.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> item = s2.pop()</span><br><span class="line">            list.push(item.val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便记忆，可以这样记：<strong>前序遍历对应的前是根节点最先访问。中序遍历对应的前是根节点放在中间访问。后序遍历对应的前是根节点最后才访问。</strong></p><p>这三种遍历方式都有 <code>递归</code> 和 <code>循环</code> 两种不同的实现方式，但是面试官更喜欢考我们的是循环实现方式，所以我们应该要掌握这三种遍历的六种遍历方式!</p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>如果说深度优先遍历是在一个方向上“一头扎到底”，那么广度优先遍历 则恰恰相反: 先在各个方向上各走出1步，再在各个方向上走出第2步、 第3步……一直到各个方向全部走完。听起来有些抽象，下面让我们通 过二叉树的层序遍历 ，来看一看广度优先是怎么回事。</p><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关 系，一层一层横向遍历各个节点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层序遍历</span></span><br><span class="line"><span class="keyword">const</span> levelOrderTraverse = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [root]</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(queue.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = queue.shift()</span><br><span class="line">        list.push(node.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.push(node.left)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.push(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><code>二叉搜索树</code>：左子节点总是小于或等于根节点，而右节点总是大于或等于根节点。可以在 <code>O(logn)</code> 内根据数值在二叉搜索树中找到一个节点</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><code>堆</code>：分为最大堆和最小堆。最大堆中根节点的值最大，在最小堆中根节点的值最小。需要快速找到最大值或最小值都可以用堆来解决</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><code>红黑树</code>：把树中的节点定义为红，黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想普及一下树的知识，个人认为树是算法必须要牢牢掌握的一部分。&lt;/p&gt;
&lt;p&gt;一般树的逻辑可以说是灰常滴简单了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;除根节点之外的每个节点只有一个父节点，根节点没有父节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除叶节点之外所有节点都有一个或多个子节点，叶节点没有子节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;父节点和子节点之间是用指针连接，所以树会涉及到大量的指针，因此与树有关的面试题都不太容易，但是越不容易的知识点，我们就越要攻克。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="树" scheme="http://yoursite.com/blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-重建二叉树</title>
    <link href="http://yoursite.com/blog/2020/03/19/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/blog/2020/03/19/剑指offer-javascript版-重建二叉树/</id>
    <published>2020-03-19T13:13:35.000Z</published>
    <updated>2020-03-23T22:12:10.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题07. 重建二叉树</p></blockquote><p><strong>题目描述</strong>：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><a id="more"></a><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给出</span><br><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="解法：二叉树的前序遍历和中序遍历"><a href="#解法：二叉树的前序遍历和中序遍历" class="headerlink" title="解法：二叉树的前序遍历和中序遍历"></a>解法：二叉树的前序遍历和中序遍历</h2><p>二叉树的前序遍历中，第一个数字是二叉树的根节点。在中序遍历中，根节点位于序列的中间，即根节点的左边是左子树节点的值，右边是右子树节点的值。</p><p>由前序遍历 <code>[3,9,20,15,7]</code> 可知，<code>3</code> 是根节点。中序遍历 <code>[9,3,15,20,7]</code> 可知，根节点 <code>3</code> 的左边是左子树节点 <code>9</code>，右边是右子树节点 <code>15</code>，<code>20</code>，<code>7</code>。所以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!preorder.length || !inorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rootVal = preorder[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(rootVal)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i有两个含义，一个是根节点在中序遍历结果中的下标， 另一个是当前左子树的节点个数</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; inorder.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] === rootVal) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i主要是求出根节点在中序遍历序列中的位置。那么i位置前面的都是左子树的值，后边的都是右子树的值。</span></span><br><span class="line">    <span class="comment">// 中序遍历和前序遍历的左子树和右子树节点的个数都分别相等</span></span><br><span class="line">    <span class="comment">// preorder.slice(1, i+1) 在前序遍历里面，左节点有多少个</span></span><br><span class="line">    <span class="comment">// inorder.slice(0, i) 在中序遍历里面，左节点就是根节点位置i前面的那些</span></span><br><span class="line">    node.left = buildTree(preorder.slice(<span class="number">1</span>, i+<span class="number">1</span>), inorder.slice(<span class="number">0</span>, i))</span><br><span class="line">    node.right = buildTree(preorder.slice(i+<span class="number">1</span>), inorder.slice(i + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题07. 重建二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/blog/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="树" scheme="http://yoursite.com/blog/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-从尾到头打印链表</title>
    <link href="http://yoursite.com/blog/2020/03/19/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/blog/2020/03/19/剑指offer-javascript版-从尾到头打印链表/</id>
    <published>2020-03-19T12:41:23.000Z</published>
    <updated>2020-03-21T10:16:58.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题06. 从尾到头打印链表</p></blockquote><p><strong>题目描述</strong>：输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法一，使用栈"><a href="#解法一，使用栈" class="headerlink" title="解法一，使用栈"></a>解法一，使用栈</h2><p>不改变链表的前提下。</p><p>遍历链表的顺序都是从头到尾，但是输出的顺序是从尾到头，也就是说第一个遍历的节点最后一个输出，最后一个遍历的节点第一个输出。这个不就是<strong>后进先出</strong> 吗？那么我们可以使用 <code>栈</code> 来实现这种做法。</p><ul><li>每经过一个节点的时候，就把该节点放到一个栈中，当遍历完整个链表后。再从栈顶逐个输出节点的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> printReverseListNode = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈用来存放已经遍历过的数组</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> curNode = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(curNode) &#123;</span><br><span class="line">        stack.push(curNode.val)</span><br><span class="line"></span><br><span class="line">        curNode = curNode.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.reverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用栈来解决这类问题，是非常的简单。但是我们也要熟知栈的各种概念，我们才能在解题的时候游刃有余，一点都不慌。</p><p>当然啦，我们也可以使用递归来实现这种解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> printReverseListNode = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">const</span> stack =[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getReverseListNode = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">                printReverseListNode(head.next)</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(head.val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getReverseListNode(head)</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题06. 从尾到头打印链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.val = val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.next = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/blog/tags/%E6%A0%88/"/>
    
      <category term="链表" scheme="http://yoursite.com/blog/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-替换空格</title>
    <link href="http://yoursite.com/blog/2020/03/18/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/blog/2020/03/18/剑指offer-javascript版-替换空格/</id>
    <published>2020-03-18T13:29:41.000Z</published>
    <updated>2020-03-21T10:16:58.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题05. 替换空格</p></blockquote><p><strong>题目描述</strong>：请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"We are happy."</span></span><br><span class="line">输出：<span class="string">"We%20are%20happy."</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"We are happy."</span></span><br><span class="line">输出：<span class="string">"We%20are%20happy."</span></span><br></pre></td></tr></table></figure><h2 id="解法一，正则表达式"><a href="#解法一，正则表达式" class="headerlink" title="解法一，正则表达式"></a>解法一，正则表达式</h2><p>字符串有一个 <code>replace</code> 方法，可以把字符串里面特定的字符转换成我们想要的字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/ /g</span>, <span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一句代码就搞定，这方法真香</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>使用字符串的分割 <code>split</code> 和 数组的分割 <code>join</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.spilt(<span class="string">' '</span>).join(<span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，虽然这种 <code>api</code> 是香，但是只能作为一种辅助的方法，面试官更多想考我们的算法能力和解题思路，这种只能用来当作题目的一种解法</p><h2 id="解法三，双指针"><a href="#解法三，双指针" class="headerlink" title="解法三，双指针"></a>解法三，双指针</h2><p>遍历原字符串，统计空格和非空格字符个数，计算替换后的新字符的长度，准备两个指针，指针 i 指向原字符串，指针 j 指向新字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s || !s.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emptyNum 空格的个数</span></span><br><span class="line">    <span class="comment">// chNum 非空字符的个数</span></span><br><span class="line">    <span class="keyword">let</span> emptyNum = <span class="number">0</span>, chNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = s.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === <span class="string">' '</span>) &#123;</span><br><span class="line">            ++emptyNum</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++chNum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> length = emptyNum * <span class="number">2</span> + chNum</span><br><span class="line">    <span class="keyword">const</span> chs = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line">    <span class="comment">// i 是新字符串的下标，j是源字符串的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j] === <span class="string">" "</span>) &#123;</span><br><span class="line">            chs[i++] = <span class="string">"%"</span></span><br><span class="line">            chs[i++] = <span class="string">"2"</span></span><br><span class="line">            chs[i++] = <span class="string">"0"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chs[i++] = s[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chs.join(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题05. 替换空格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：请实现一个函数，把字符串 s 中的每个空格替换成”%20”。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;We are happy.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;We%20are%20happy.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-二维数组中的查找</title>
    <link href="http://yoursite.com/blog/2020/03/18/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/blog/2020/03/18/剑指offer-javascript版-二维数组中的查找/</id>
    <published>2020-03-18T12:54:15.000Z</published>
    <updated>2020-03-21T10:16:58.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题04. 二维数组中的查找</p></blockquote><p><strong>题目描述</strong>：在一个 <code>n * m</code> 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 <code>n * m</code> 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解法一，暴力求解法"><a href="#解法一，暴力求解法" class="headerlink" title="解法一，暴力求解法"></a>解法一，暴力求解法</h2><p>因为是 <code>n * m</code> 的二维数组，所以我们可以直接使用双层遍历来遍历整个二维数组的项。注意，该方法不管你数组是递增还是递减的规律，直接一梭子遍历就完事了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 多少行</span></span><br><span class="line">    <span class="keyword">const</span> rowLength = matrix.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!rowLength) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多少列</span></span><br><span class="line">    <span class="keyword">const</span> colLength = matrix[<span class="number">0</span>].length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!colLength) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowLength; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; colLength; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] === target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，我们也可以使用数组提供的 <code>API</code> 去解决这道问题，例如：<code>indexOf</code>，<code>includes</code>，但是由于该种做法过于简单，我们刷题的时候应该尽量避免使用此类 <code>API</code>，下面讲述一下思路：</p><ul><li>遍历数组的每一个项，再使用数组的每一项去判断子数组中是否存在目标元素（<code>indexOf</code> 判断子数组中目标元素的位置，可以用是否大于 <code>-1</code> 来判断，<code>includes</code> 则是判断数组中是否存在某元素，存在则返回 <code>true</code>，否则返回 <code>false</code>）</li></ul><h2 id="解法二，发现规律"><a href="#解法二，发现规律" class="headerlink" title="解法二，发现规律"></a>解法二，发现规律</h2><p>从题目描述中可以发现二维数组中的每一行都按照从左到右递增，每一列都按照从上到下递增。我们可以利用这一规律作为解题的突破口，那么</p><ul><li><p>从数组中选取一个数组，分三种情况来分析查找的过程</p></li><li><p>如果数组中选取的数字刚好等于目标元素，那么直接返回 <code>true</code>，结束查找。</p></li><li><p>如果选取的数字小于目标元素，那么目标元素的位置应该在选取的数字的右边或者下边</p></li><li><p>同样，如果选取的数字大于目标元素，那么目标元素的位置应该在选取的数字的左边或者上边</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> rowLength = matrix.length</span><br><span class="line">    <span class="keyword">if</span>(!rowLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> colLength = matrix[<span class="number">0</span>].length</span><br><span class="line">    <span class="keyword">if</span>(!colLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>, col = colLength - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(row &lt; rowLength &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] === target) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 第三种情况</span></span><br><span class="line">            --col</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第二种情况</span></span><br><span class="line">            ++row</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题04. 二维数组中的查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：在一个 &lt;code&gt;n * m&lt;/code&gt; 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/blog/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>强缓存和协商缓存</title>
    <link href="http://yoursite.com/blog/2020/03/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/blog/2020/03/18/浏览器缓存/</id>
    <published>2020-03-17T23:34:00.000Z</published>
    <updated>2020-03-21T10:16:58.219Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直对浏览器缓存只能描述一个大概，深层次的原理不能描述上来；为了泄恨，查阅一些资料最终对其有了一个更深入的理解</p><p>本文主要讲解浏览器端的缓存，缓存的作用是不言而喻的，能够极大的改善网页性能，提高用户体验。</p><a id="more"></a><h2 id="浏览器缓存的基本认识"><a href="#浏览器缓存的基本认识" class="headerlink" title="浏览器缓存的基本认识"></a>浏览器缓存的基本认识</h2><p>分为<strong>强缓存</strong> 和 <strong>协商缓存</strong></p><p>（1）浏览器在加载资源的时候，会根据HTTP的头部header<strong>判断它是否命中强缓存，强缓存如果直接命中，那么浏览器就会直接从自己的缓存中读取资源，而不会请求到服务器</strong>。比如某个css文件，如果浏览器在加载这个文件的时候，从这个文件的http头部判断命中了缓存，那么就会直接从内存中读取这个css文件，而不会再去请求服务器。</p><p>（2）当强缓存没有命中的时候，<strong>那么浏览器就会发送http请求到服务器，通过服务器依据资源的另外一些http头部去验证这个资源是否命中协商缓存，如果协商缓存命中，服务器就将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器可以直接从缓存中读取这个资源，那么浏览器就会从缓存中读取这个资源</strong>。</p><p>（3）<strong>强缓存和协商缓存的共同点：如果命中，那么都会从客户端的缓存中去读取资源，而不是从服务器中读取资源。不同的是，强缓存不会发送请求到服务器，而协商缓存则需要发送请求到服务器。</strong></p><p>（4）如果协商缓存也没有命中的时候，浏览器直接从服务器中加载资源数据。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>当浏览器对某个资源的请求命中了强缓存时，返回的 <code>http</code> 状态为200，在 <code>chrome</code> 的开发者工具的 <code>network</code> 里面 <code>size</code> 会显示为 <code>from cache</code>。</p><p>强缓存是利用 <code>Expires</code> 或者 <code>Cache-Control</code> 这两个 <code>http response header</code> 实现的，它们都用来表示资源在客户端缓存的有效期。</p><h4 id="一，Expires"><a href="#一，Expires" class="headerlink" title="一，Expires"></a>一，Expires</h4><p><code>Expires</code> 是 <code>http1.0</code> 提出的一个表示资源过期时间的 <code>header</code>，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p><p>（1）浏览器第一次跟服务器请求一个资源的时候，服务器在返回这个资源的同时，会在 <code>response</code> 的 header 加上 <code>Expires</code> 的 <code>header</code>，如</p><p><img src="/images/expires.jpeg" alt="一，Expires"></p><p>（2）浏览器在接收到这个资源后，会把这个资源连同所有的 <code>response header</code> 一起缓存下来（所有缓存命中的请求返回的 <code>header</code> 并不是来自服务器，而是来自之前缓存的 <code>header</code>）</p><p>（3）浏览器再请求这个资源的时候，会先从缓存中去寻找，最好找到这个资源后，会拿当前的时间和Expire设置的时间比较，如果当前请求的时间在 <code>Expires</code> 指定的时间之前，那么就能命中缓存，否则不命中。</p><p>（4）如果缓存没有命中，那么浏览器直接从服务器中加载资源时，<code>Expire Header</code> 在重新加载的时候就会被更新。</p><p>  <strong>弊端：Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。</strong></p><p>所以在 <code>HTTP1.1</code> 的时候，就提出了一个新的header：<code>Cache-Control</code>，这是一个相对的时间，在配置缓存的时候以秒为单位，用数值表示，如：Cache-Control：max-age=315360000</p><h4 id="二，Cache-Control"><a href="#二，Cache-Control" class="headerlink" title="二，Cache-Control"></a>二，Cache-Control</h4><p>（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 <code>respone</code> 的 <code>header</code> 加上 <code>Cache-Control</code> 的 <code>header</code>，如：</p><p><img src="/images/cacheControl.png" alt="二，Cache-Control"></p><p>（2）浏览器在接收到这个资源后，会把这个资源连同所有 <code>response header</code> 一起缓存下来；</p><p>（3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 <code>Cache-Control</code> 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。（4）如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Cache-Control Header</code> 在重新加载的时候会被更新。</p><p><code>Cache-Control</code> 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。这两个header可以只启用一个，也可以同时启用，当<code>response header</code> 中，<code>Expires</code> 和 <code>Cache-Control</code> 同时存在时，<code>Cache-Control</code> 优先级高于<code>Expires</code>：</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个<code>Not Modified</code>的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看 <code>network</code>，可以看到有不少请求就是命中了协商缓存的：</p><p><img src="/images/304.png" alt="协商缓存"></p><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的</p><h4 id="一，【Last-Modified，If-Modified-Since】"><a href="#一，【Last-Modified，If-Modified-Since】" class="headerlink" title="一，【Last-Modified，If-Modified-Since】"></a>一，【Last-Modified，If-Modified-Since】</h4><p>（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，<strong>在respone的header加上 <code>Last-Modified</code> 的header</strong>，这个header表示这个资源在服务器上的最后修改时间：</p><p><img src="/images/lastModify.png" alt="Last-Modified"></p><p>（2）浏览器再次跟服务器请求这个资源时，<strong>在request的header上加上 <code>If-Modified-Since</code> 的header</strong>，这个header的值就是上一次请求时返回的<code>Last-Modified</code>的值：</p><p><img src="/images/ifModifySince.png" alt="If-Modified-Since"></p><p>（3）服务器再次收到资源请求时，根据浏览器传过来 <code>If-Modified-Since</code> 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加 <code>Last-Modified</code>的header，因为既然资源没有变化，那么 <code>Last-Modified</code> 也就不会改变，这是服务器返回304时的 `response header ：</p><p><img src="/images/header.png" alt="header"></p><p>（4）浏览器收到304的响应后，就会从缓存中加载资源。<br>（5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，<code>Last-Modified</code>Header在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code>会启用上次返回的<code>Last-Modified</code>值。</p><p>  <strong>弊端：【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。</strong></p><p>所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。</p><h4 id="二，【ETag、If-None-Match】"><a href="#二，【ETag、If-None-Match】" class="headerlink" title="二，【ETag、If-None-Match】"></a>二，【ETag、If-None-Match】</h4><p>（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上<code>ETag</code>的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个<strong>唯一标识是一个字符串</strong>，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：</p><p><img src="/images/etag.png" alt="Etag"></p><p>（2）浏览器再次跟服务器请求这个资源时，<strong><em>在request的header上加上<code>If-None-Match</code>的header，这个header的值就是上一次请求时返回的ETag的值</em></strong>：</p><p><img src="/images/ifNoMatch.png" alt="If-None-Match"></p><p>（3）服务器再次收到资源请求时，根据浏览器传过来<code>If-None-Match</code>和然后再根据资源生成一个新的<code>ETag</code>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：</p><p><img src="/images/etag2.png" alt="new Etag"></p><p>（4）浏览器收到304的响应后，就会从缓存中加载资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直对浏览器缓存只能描述一个大概，深层次的原理不能描述上来；为了泄恨，查阅一些资料最终对其有了一个更深入的理解&lt;/p&gt;
&lt;p&gt;本文主要讲解浏览器端的缓存，缓存的作用是不言而喻的，能够极大的改善网页性能，提高用户体验。&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/blog/categories/http/"/>
    
    
      <category term="http" scheme="http://yoursite.com/blog/tags/http/"/>
    
      <category term="缓存" scheme="http://yoursite.com/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>如何理解Javascript中的this</title>
    <link href="http://yoursite.com/blog/2020/03/17/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84this/"/>
    <id>http://yoursite.com/blog/2020/03/17/如何理解javascript中的this/</id>
    <published>2020-03-17T15:27:26.000Z</published>
    <updated>2020-03-21T10:16:58.218Z</updated>
    
    <content type="html"><![CDATA[<p>关于this指向的文章，网上一搜一大把，可是很多文章都是复制粘贴的水文，是否真正的了解JavaScript中的this，那就未必。那么我们应该如何简单轻松的理解this呢？</p><p>要简单轻松的理解this，就要记住一句话：<strong>this的指向并不是在函数定义的时候确定的，而是在其被调用的时候确定的</strong>。也就是说，<strong>this是在运行的时候基于函数的执行环境绑定的。</strong></p><p>this的指向可以分为5大类：</p><a id="more"></a><ul><li>纯粹的函数调用</li><li>作为对象的属性调用</li><li>作为构造函数调用</li><li>apply,call调用</li><li>箭头函数调用</li></ul><h3 id="一、-纯粹的函数调用"><a href="#一、-纯粹的函数调用" class="headerlink" title="一、 纯粹的函数调用"></a>一、 纯粹的函数调用</h3><p> 纯粹的函数调用，也就是最普遍的函数调用方式。非严格模式下，this指向的是window。严格模式下，this指向了undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式下</span><br><span class="line">var a = 10;    // 全局变量相当于在window上面挂载属性a，window.a</span><br><span class="line">function func() &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();    // 10</span><br><span class="line"></span><br><span class="line">// 严格模式下</span><br><span class="line">var b = 10;</span><br><span class="line">function func1() &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    console.log(this.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1();    // Uncaught TypeError: Cannot read property &apos;b&apos; of undefined</span><br></pre></td></tr></table></figure><h3 id="二、作为对象的属性调用"><a href="#二、作为对象的属性调用" class="headerlink" title="二、作为对象的属性调用"></a>二、作为对象的属性调用</h3><p>函数作为对象的属性调用时候，this 指向这个对象。（实际上纯粹的函数调用也可以算是作为对象的函数调用，因为全局变量是直接挂载在window上的，所以 func() 也就相当于 window.func() ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    func: func</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.func()    // this指向了obj，所以this.a会打印出10</span><br></pre></td></tr></table></figure><p>要注意的是，如果像下面这种情况，this 指向的是window的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    func: func</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func1 = obj.func</span><br><span class="line"></span><br><span class="line">func1()    // 20, this指向了window</span><br></pre></td></tr></table></figure><p>所以说还得看函数调用的位置。</p><h3 id="三、作为构造函数调用"><a href="#三、作为构造函数调用" class="headerlink" title="三、作为构造函数调用"></a>三、作为构造函数调用</h3><p>通过构造函数，可以生成一个新对象（这个也就是我们经常说的实例）。这时，this就指这个新对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Func() &#123;</span><br><span class="line">    this.a = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = new Func()</span><br><span class="line">console.log(obj.a);    // 10</span><br></pre></td></tr></table></figure><p>使用new调用构造函数实际上会经历四个过程：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象。（this指向了新对象）</li><li>执行构造函数中的代码。（挂载属性）</li><li>返回新的对象</li></ol><p>如何手动实现new的功能？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">    // 创建一个新的对象</span><br><span class="line">    var obj = new Object(),</span><br><span class="line">    // 获得构造函数，arguments中去除第一个参数，Func指的是构造函数</span><br><span class="line">    Func = [].shift.call(arguments);</span><br><span class="line">    // 将构造函数的作用域赋给新对象。</span><br><span class="line">    obj.__proto__ = Func.prototype;</span><br><span class="line">    // 执行构造函数中的代码，使obj 可以访问到构造函数中的属性</span><br><span class="line">    var res = Func.apply(obj, arguments);</span><br><span class="line">    // 返回新的对象。判断构造函数的返回值是否是对象，如果是就返回。不是就返回新的对象。</span><br><span class="line">    return res instanceof Object ? res : obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Func() &#123;</span><br><span class="line">    this.a = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用new</span><br><span class="line">var func1 = new Func()</span><br><span class="line">                        </span><br><span class="line">// 使用手写的new，即create</span><br><span class="line">var func2 = create(Func)</span><br><span class="line"></span><br><span class="line">console.log(func1, func2); // &#123;a: 20&#125;, &#123;a: 20&#125;</span><br></pre></td></tr></table></figure><h3 id="四、apply、call调用"><a href="#四、apply、call调用" class="headerlink" title="四、apply、call调用"></a>四、apply、call调用</h3><p>apply、call都是是函数的一个方法，作用是改变函数的调用对象。它们的第一个参数就表示改变后的调用这个函数的对象。this 指的就是这第一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 20</span><br><span class="line">&#125;</span><br><span class="line">function func() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj);    // 20</span><br><span class="line">func.apply(obj);    // 20</span><br></pre></td></tr></table></figure><p>不同的是，apply的第二个参数是一个数组或者类数组对象，而call的是指定的参数列表。</p><h3 id="五、箭头函数调用"><a href="#五、箭头函数调用" class="headerlink" title="五、箭头函数调用"></a>五、箭头函数调用</h3><p>箭头函数有两个作用，更简短的函数并且不绑定this。即箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承 this 。简单点来说，箭头函数的 this 会继承外层不为箭头函数的函数的 this</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">function func() &#123;</span><br><span class="line">    var fun1 = () =&gt; &#123;</span><br><span class="line">        console.log(this.a)</span><br><span class="line">    &#125;</span><br><span class="line">    return fun1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func()();    // 20，箭头函数fun1的this会从外层不为箭头函数的函数func继承而来。func的this指向了window，所以this.a是20</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于this指向的文章，网上一搜一大把，可是很多文章都是复制粘贴的水文，是否真正的了解JavaScript中的this，那就未必。那么我们应该如何简单轻松的理解this呢？&lt;/p&gt;
&lt;p&gt;要简单轻松的理解this，就要记住一句话：&lt;strong&gt;this的指向并不是在函数定义的时候确定的，而是在其被调用的时候确定的&lt;/strong&gt;。也就是说，&lt;strong&gt;this是在运行的时候基于函数的执行环境绑定的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;this的指向可以分为5大类：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/blog/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/blog/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-找出数组中的数字</title>
    <link href="http://yoursite.com/blog/2020/03/17/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/blog/2020/03/17/剑指offer-javascript版-找出数组中的数字/</id>
    <published>2020-03-17T13:56:26.000Z</published>
    <updated>2020-03-21T10:16:58.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题03. 数组中重复的数字</p></blockquote><p><strong>题目描述</strong>：在一个长度为 <code>n</code> 的数组 <code>nums</code> 里的所有数字都在 <code>0～n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 <code>n</code> 的数组 <code>nums</code> 里的所有数字都在 <code>0～n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字</p><h2 id="解法一，暴力求解法"><a href="#解法一，暴力求解法" class="headerlink" title="解法一，暴力求解法"></a>解法一，暴力求解法</h2><p>先把输入的数字排序，从排序的数字中找出重复的数字，即需要从头到尾扫描排序后的数组就可以了，排序一个长度为 <code>n</code> 的数组需要 <code>O(nlogn)</code> 的时间（排序最快的速度是 <code>O(nlogn)</code> ，即快速排序）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findRepeatNumber = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 先排序</span></span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 比较前后的值是否相同</span></span><br><span class="line">    <span class="keyword">if</span>(nums[i] === nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可想而知，这种解法并不是那么令人满意，因为需要先把数组排序</p><h2 id="解法二，使用对象"><a href="#解法二，使用对象" class="headerlink" title="解法二，使用对象"></a>解法二，使用对象</h2><p>使用对象来解决这个问题，从头到尾遍历整个数组，依次把数组的每一项当作对象的 <code>key</code> 值存进对象。如果数组的某个项在对象中存在，那么我们就可以认为这个值在数组中重复了，直接返回即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> findRepeatNumber = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用来存放是否遍历过的数组的项</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 数组的项是否已经是对象obj的键值了</span></span><br><span class="line">    <span class="keyword">if</span>(obj[nums[i]]) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[i]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[nums[i]] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三，数学分析法"><a href="#解法三，数学分析法" class="headerlink" title="解法三，数学分析法"></a>解法三，数学分析法</h2><p>从头到尾遍历数组</p><ul><li><p>当数组下标为 <code>i</code> 的时候，比较这个数字（用 <code>m</code> 表示）是不是等于 <code>i</code>，如果是，则接着扫描下一个数字。</p></li><li><p>如果不是，拿它与第 <code>m</code> 个数字进行比较。如果它和第 <code>m</code> 个数字相等，就找到了一个重复的数组（<code>i</code> 和 <code>m</code> 的位置上都存在数字 <code>m</code>）。如果它和第 <code>m</code> 个数字不相等，就把第 <code>i</code> 个位置上的数字和第 <code>m</code> 个位置上的数字交换，那么 第 <code>m</code> 位上的数字就是 <code>m</code> 了</p></li><li><p>重复这个比较，直到发现一个重复的数字</p></li></ul><p><strong>[2, 3, 1, 0, 2, 5, 3] 举个例子：</strong></p><ul><li><p>首先遍历这个数组，从 <code>0</code> 位置上开始遍历。<code>0</code> 上面的数字是 <code>2</code>，那么我们可以直接拿数字 <code>2</code> 和 <code>2</code> 位置上的 <code>1</code> 做比较，结果不相等，交换位置。交换之后的数组是 <strong>[1, 3, 2, 0, 2, 5, 3]</strong></p></li><li><p>此时 <code>0</code> 位置上面的数字是 <code>1</code>，仍然不相等，继续和下标为 <code>1</code> 的 数字 <code>3</code> 做交换。交换之后的数组是 <strong>[3, 1, 2, 0, 2, 5, 3]</strong></p></li><li><p>此时 <code>0</code> 位置上面的数字是 <code>3</code>，仍然不相等，继续和下标为 <code>3</code> 的 数字 <code>0</code> 做交换。交换之后的数组是 <strong>[0, 1, 2, 3, 2, 5, 3]</strong></p></li><li><p>这时候 <code>0</code> 位置上的数字是 <code>0</code> 了，那么我们可以直接遍历下一个数字了，可知接下来的数字 <code>1</code>，<code>2</code>，<code>3</code> 都与坐标相等，不用进行交换操作。</p></li><li><p>接下来到位置 <code>4</code> 的数字 <code>2</code> ，由于数字与位置不相等，再比较位置 <code>2</code> 上的数字。发现位置 <code>2</code> 上的数字也是 <code>2</code> 了，因此我们便找到了一个重复的数字</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> findRepeatNumber = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(nums[i] !== i) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i] === nums[nums[i]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 交换数组两个位置上的项，这里是i 和 num[i] 交换</span></span><br><span class="line">      <span class="keyword">let</span> temp= nums[i]</span><br><span class="line">      nums[i] = nums[temp]</span><br><span class="line">      nums[temp] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题03. 数组中重复的数字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：在一个长度为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; 里的所有数字都在 &lt;code&gt;0～n-1&lt;/code&gt; 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/blog/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>

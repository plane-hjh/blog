<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>plane&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-21T10:16:58.219Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hejianhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树</title>
    <link href="http://yoursite.com/2020/03/21/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2020/03/21/树的遍历/</id>
    <published>2020-03-21T09:08:04.000Z</published>
    <updated>2020-03-21T10:16:58.219Z</updated>
    
    <content type="html"><![CDATA[<p>想普及一下树的知识，个人认为树是算法必须要牢牢掌握的一部分。</p><p>一般树的逻辑可以说是灰常滴简单了：</p><ul><li><p>除根节点之外的每个节点只有一个父节点，根节点没有父节点。</p></li><li><p>除叶节点之外所有节点都有一个或多个子节点，叶节点没有子节点。</p></li></ul><p>父节点和子节点之间是用指针连接，所以树会涉及到大量的指针，因此与树有关的面试题都不太容易，但是越不容易的知识点，我们就越要攻克。</p><a id="more"></a><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>但是面试时候提到的树，大部分都是二叉树。二叉树是树的一种特殊结构，在二叉树中每个节点最多只能有两个子节点。在二叉树中最重要的考点莫过于树的遍历，即按照某一个顺序遍历访问树中的所有节点。</p><p>二叉树的遍历可以有以下几种：</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul><li><code>前序遍历</code>：先访问根节点，再访问左节点，最后访问右节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="keyword">const</span> preOrderTraverse = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> preOrder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 先访问根节点</span></span><br><span class="line">            list.push(node.val)</span><br><span class="line">            <span class="comment">// 再访问左节点</span></span><br><span class="line">            preOrder(node.left)</span><br><span class="line">            <span class="comment">// 最后访问右节点</span></span><br><span class="line">            preOrder(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归版本</span></span><br><span class="line"><span class="keyword">const</span> preOrderTraverseUnRecur = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = [];</span><br><span class="line">    <span class="keyword">let</span> stack = [root];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> curNode = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> left = curNode.left</span><br><span class="line">        <span class="keyword">const</span> right = curNode.right</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一步的时候，先访问的是根节点</span></span><br><span class="line">        list.push(curNode.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right) &#123;</span><br><span class="line">            stack.push(right)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为pop是取出最后一个元素，所以我们要确保首先拿到的是左节点</span></span><br><span class="line">        <span class="keyword">if</span>(left) &#123;</span><br><span class="line">            stack.push(left)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul><li><code>中序遍历</code>：先访问左节点，再访问中节点，最后访问右节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="keyword">const</span> inOrderTraverse = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> inOrder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node !== <span class="literal">null</span>) &#123;</span><br><span class="line">            inOrder(node.left)</span><br><span class="line">            list.push(node.val)</span><br><span class="line">            inOrder(node.right)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inOrder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归版本</span></span><br><span class="line"><span class="keyword">const</span> inOrderTraverseUnRecur = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="comment">// 借助了栈，先进后出的概念</span></span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> head = root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.length !== <span class="number">0</span> || head !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(head !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            stack.push(head)</span><br><span class="line">            head = head.left</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            head = stack.pop()</span><br><span class="line">            list.push(head.val)</span><br><span class="line">            head = head.right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul><li><code>后序遍历</code>：先访问左节点，再访问右节点，最后访问根节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">const</span> postOrderTraverse = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> postOrder = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) &#123;</span><br><span class="line">            postOrder(node.left)</span><br><span class="line">            postOrder(node.right)</span><br><span class="line">            list.push(node.val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postOrder(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="keyword">const</span> postOrderTraverseUnRecur = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> list = []</span><br><span class="line">    <span class="keyword">if</span>(root !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> s1 = []</span><br><span class="line">        <span class="keyword">let</span> s2 = []</span><br><span class="line"></span><br><span class="line">        s1.push(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(s1.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            head = s1.pop()</span><br><span class="line">            s2.push(head)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head.left !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                s1.push(head.left)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(head.right !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">                s1.push(head.right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(s2.length !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> item = s2.pop()</span><br><span class="line">            list.push(item.val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便记忆，可以这样记：<strong>前序遍历对应的前是根节点最先访问。中序遍历对应的前是根节点放在中间访问。后序遍历对应的前是根节点最后才访问。</strong></p><p>这三种遍历方式都有 <code>递归</code> 和 <code>循环</code> 两种不同的实现方式，但是面试官更喜欢考我们的是循环实现方式，所以我们应该要掌握这三种遍历的六种遍历方式!</p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><ul><li><code>广度优先遍历</code>：即先访问树的第一层节点，接着访问第二层节点…一直访问到最后一层节点</li></ul><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><ul><li><code>深度优先遍历</code>：即先访问树的根节点，再访问根节点的子节点，先往深层访问，深层访问节点结束了，再返回访问同层节点，之后再继续往深层访问节点…</li></ul><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><code>二叉搜索树</code>：左子节点总是小于或等于根节点，而右节点总是大于或等于根节点。可以在 <code>O(logn)</code> 内根据数值在二叉搜索树中找到一个节点</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><code>堆</code>：分为最大堆和最小堆。最大堆中根节点的值最大，在最小堆中根节点的值最小。需要快速找到最大值或最小值都可以用堆来解决</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><code>红黑树</code>：把树中的节点定义为红，黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想普及一下树的知识，个人认为树是算法必须要牢牢掌握的一部分。&lt;/p&gt;
&lt;p&gt;一般树的逻辑可以说是灰常滴简单了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;除根节点之外的每个节点只有一个父节点，根节点没有父节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;除叶节点之外所有节点都有一个或多个子节点，叶节点没有子节点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;父节点和子节点之间是用指针连接，所以树会涉及到大量的指针，因此与树有关的面试题都不太容易，但是越不容易的知识点，我们就越要攻克。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-重建二叉树</title>
    <link href="http://yoursite.com/2020/03/19/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2020/03/19/剑指offer-javascript版-重建二叉树/</id>
    <published>2020-03-19T13:13:35.000Z</published>
    <updated>2020-03-21T10:16:58.218Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题07. 重建二叉树</p></blockquote><p><strong>题目描述</strong>：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><a id="more"></a><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给出</span><br><span class="line">前序遍历 preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">中序遍历 inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span></span><br><span class="line">    /  \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="解法：二叉树的前序遍历和中序遍历"><a href="#解法：二叉树的前序遍历和中序遍历" class="headerlink" title="解法：二叉树的前序遍历和中序遍历"></a>解法：二叉树的前序遍历和中序遍历</h2><p>二叉树的前序遍历中，第一个数字是二叉树的根节点。在中序遍历中，根节点位于序列的中间，即根节点的左边是左子树节点的值，右边是右子树节点的值。</p><p>由前序遍历 <code>[3,9,20,15,7]</code> 可知，<code>3</code> 是根节点。中序遍历 <code>[9,3,15,20,7]</code> 可知，根节点 <code>3</code> 的左边是左子树节点 <code>9</code>，右边是右子树节点 <code>15</code>，<code>20</code>，<code>7</code>。所以</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!preorder.length || !inorder.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rootVal = preorder[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> node = <span class="keyword">new</span> TreeNode(rootVal)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i有两个含义，一个是根节点在中序遍历结果中的下标， 另一个是当前左子树的节点个数</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; inorder.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i] === rootVal) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i主要是求出根节点在中序遍历序列中的位置。那么i位置前面的都是左子树的值，后边的都是右子树的值。</span></span><br><span class="line">    <span class="comment">// 中序遍历和前序遍历的左子树和右子树节点的个数都分别相等</span></span><br><span class="line">    node.left = buildTree(preorder.slice(<span class="number">1</span>, i+<span class="number">1</span>), inorder.slice(<span class="number">0</span>, i))</span><br><span class="line">    node.right = buildTree(preorder.slice(i+<span class="number">1</span>), inorder.slice(i + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题07. 重建二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-从尾到头打印链表</title>
    <link href="http://yoursite.com/2020/03/19/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/03/19/剑指offer-javascript版-从尾到头打印链表/</id>
    <published>2020-03-19T12:41:23.000Z</published>
    <updated>2020-03-21T10:16:58.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题06. 从尾到头打印链表</p></blockquote><p><strong>题目描述</strong>：输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val;</span><br><span class="line">    <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法一，使用栈"><a href="#解法一，使用栈" class="headerlink" title="解法一，使用栈"></a>解法一，使用栈</h2><p>不改变链表的前提下。</p><p>遍历链表的顺序都是从头到尾，但是输出的顺序是从尾到头，也就是说第一个遍历的节点最后一个输出，最后一个遍历的节点第一个输出。这个不就是<strong>后进先出</strong> 吗？那么我们可以使用 <code>栈</code> 来实现这种做法。</p><ul><li>每经过一个节点的时候，就把该节点放到一个栈中，当遍历完整个链表后。再从栈顶逐个输出节点的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> printReverseListNode = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈用来存放已经遍历过的数组</span></span><br><span class="line">    <span class="keyword">const</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> curNode = head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(curNode) &#123;</span><br><span class="line">        stack.push(curNode.val)</span><br><span class="line"></span><br><span class="line">        curNode = curNode.next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.reverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，使用栈来解决这类问题，是非常的简单。但是我们也要熟知栈的各种概念，我们才能在解题的时候游刃有余，一点都不慌。</p><p>当然啦，我们也可以使用递归来实现这种解法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> printReverseListNode = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">const</span> stack =[]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> getReverseListNode = <span class="function">(<span class="params">head</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">                printReverseListNode(head.next)</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(head.val)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getReverseListNode(head)</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题06. 从尾到头打印链表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.val = val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.next = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-替换空格</title>
    <link href="http://yoursite.com/2020/03/18/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://yoursite.com/2020/03/18/剑指offer-javascript版-替换空格/</id>
    <published>2020-03-18T13:29:41.000Z</published>
    <updated>2020-03-21T10:16:58.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题05. 替换空格</p></blockquote><p><strong>题目描述</strong>：请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"We are happy."</span></span><br><span class="line">输出：<span class="string">"We%20are%20happy."</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><p>例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"We are happy."</span></span><br><span class="line">输出：<span class="string">"We%20are%20happy."</span></span><br></pre></td></tr></table></figure><h2 id="解法一，正则表达式"><a href="#解法一，正则表达式" class="headerlink" title="解法一，正则表达式"></a>解法一，正则表达式</h2><p>字符串有一个 <code>replace</code> 方法，可以把字符串里面特定的字符转换成我们想要的字符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/ /g</span>, <span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一句代码就搞定，这方法真香</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>使用字符串的分割 <code>split</code> 和 数组的分割 <code>join</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.spilt(<span class="string">' '</span>).join(<span class="string">'%20'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，虽然这种 <code>api</code> 是香，但是只能作为一种辅助的方法，面试官更多想考我们的算法能力和解题思路，这种只能用来当作题目的一种解法</p><h2 id="解法三，双指针"><a href="#解法三，双指针" class="headerlink" title="解法三，双指针"></a>解法三，双指针</h2><p>遍历原字符串，统计空格和非空格字符个数，计算替换后的新字符的长度，准备两个指针，指针 i 指向原字符串，指针 j 指向新字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s || !s.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emptyNum 空格的个数</span></span><br><span class="line">    <span class="comment">// chNum 非空字符的个数</span></span><br><span class="line">    <span class="keyword">let</span> emptyNum = <span class="number">0</span>, chNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = s.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === <span class="string">' '</span>) &#123;</span><br><span class="line">            ++emptyNum</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++chNum</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> length = emptyNum * <span class="number">2</span> + chNum</span><br><span class="line">    <span class="keyword">const</span> chs = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line">    <span class="comment">// i 是新字符串的下标，j是源字符串的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[j] === <span class="string">" "</span>) &#123;</span><br><span class="line">            chs[i++] = <span class="string">"%"</span></span><br><span class="line">            chs[i++] = <span class="string">"2"</span></span><br><span class="line">            chs[i++] = <span class="string">"0"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            chs[i++] = s[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chs.join(<span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题05. 替换空格&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：请实现一个函数，把字符串 s 中的每个空格替换成”%20”。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;We are happy.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;We%20are%20happy.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-二维数组中的查找</title>
    <link href="http://yoursite.com/2020/03/18/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/03/18/剑指offer-javascript版-二维数组中的查找/</id>
    <published>2020-03-18T12:54:15.000Z</published>
    <updated>2020-03-21T10:16:58.216Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题04. 二维数组中的查找</p></blockquote><p><strong>题目描述</strong>：在一个 <code>n * m</code> 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 <code>n * m</code> 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解法一，暴力求解法"><a href="#解法一，暴力求解法" class="headerlink" title="解法一，暴力求解法"></a>解法一，暴力求解法</h2><p>因为是 <code>n * m</code> 的二维数组，所以我们可以直接使用双层遍历来遍历整个二维数组的项。注意，该方法不管你数组是递增还是递减的规律，直接一梭子遍历就完事了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 多少行</span></span><br><span class="line">    <span class="keyword">const</span> rowLength = matrix.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!rowLength) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多少列</span></span><br><span class="line">    <span class="keyword">const</span> colLength = matrix[<span class="number">0</span>].length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!colLength) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowLength; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; colLength; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] === target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，我们也可以使用数组提供的 <code>API</code> 去解决这道问题，例如：<code>indexOf</code>，<code>includes</code>，但是由于该种做法过于简单，我们刷题的时候应该尽量避免使用此类 <code>API</code>，下面讲述一下思路：</p><ul><li>遍历数组的每一个项，再使用数组的每一项去判断子数组中是否存在目标元素（<code>indexOf</code> 判断子数组中目标元素的位置，可以用是否大于 <code>-1</code> 来判断，<code>includes</code> 则是判断数组中是否存在某元素，存在则返回 <code>true</code>，否则返回 <code>false</code>）</li></ul><h2 id="解法二，发现规律"><a href="#解法二，发现规律" class="headerlink" title="解法二，发现规律"></a>解法二，发现规律</h2><p>从题目描述中可以发现二维数组中的每一行都按照从左到右递增，每一列都按照从上到下递增。我们可以利用这一规律作为解题的突破口，那么</p><ul><li><p>从数组中选取一个数组，分三种情况来分析查找的过程</p></li><li><p>如果数组中选取的数字刚好等于目标元素，那么直接返回 <code>true</code>，结束查找。</p></li><li><p>如果选取的数字小于目标元素，那么目标元素的位置应该在选取的数字的右边或者下边</p></li><li><p>同样，如果选取的数字大于目标元素，那么目标元素的位置应该在选取的数字的左边或者上边</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> rowLength = matrix.length</span><br><span class="line">    <span class="keyword">if</span>(!rowLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> colLength = matrix[<span class="number">0</span>].length</span><br><span class="line">    <span class="keyword">if</span>(!colLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>, col = colLength - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(row &lt; rowLength &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[row][col] === target) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 第三种情况</span></span><br><span class="line">            --col</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第二种情况</span></span><br><span class="line">            ++row</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题04. 二维数组中的查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：在一个 &lt;code&gt;n * m&lt;/code&gt; 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>强缓存和协商缓存</title>
    <link href="http://yoursite.com/2020/03/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/03/18/浏览器缓存/</id>
    <published>2020-03-17T23:34:00.000Z</published>
    <updated>2020-03-21T10:16:58.219Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直对浏览器缓存只能描述一个大概，深层次的原理不能描述上来；为了泄恨，查阅一些资料最终对其有了一个更深入的理解</p><p>本文主要讲解浏览器端的缓存，缓存的作用是不言而喻的，能够极大的改善网页性能，提高用户体验。</p><a id="more"></a><h2 id="浏览器缓存的基本认识"><a href="#浏览器缓存的基本认识" class="headerlink" title="浏览器缓存的基本认识"></a>浏览器缓存的基本认识</h2><p>分为<strong>强缓存</strong> 和 <strong>协商缓存</strong></p><p>（1）浏览器在加载资源的时候，会根据HTTP的头部header<strong>判断它是否命中强缓存，强缓存如果直接命中，那么浏览器就会直接从自己的缓存中读取资源，而不会请求到服务器</strong>。比如某个css文件，如果浏览器在加载这个文件的时候，从这个文件的http头部判断命中了缓存，那么就会直接从内存中读取这个css文件，而不会再去请求服务器。</p><p>（2）当强缓存没有命中的时候，<strong>那么浏览器就会发送http请求到服务器，通过服务器依据资源的另外一些http头部去验证这个资源是否命中协商缓存，如果协商缓存命中，服务器就将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器可以直接从缓存中读取这个资源，那么浏览器就会从缓存中读取这个资源</strong>。</p><p>（3）<strong>强缓存和协商缓存的共同点：如果命中，那么都会从客户端的缓存中去读取资源，而不是从服务器中读取资源。不同的是，强缓存不会发送请求到服务器，而协商缓存则需要发送请求到服务器。</strong></p><p>（4）如果协商缓存也没有命中的时候，浏览器直接从服务器中加载资源数据。</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>当浏览器对某个资源的请求命中了强缓存时，返回的 <code>http</code> 状态为200，在 <code>chrome</code> 的开发者工具的 <code>network</code> 里面 <code>size</code> 会显示为 <code>from cache</code>。</p><p>强缓存是利用 <code>Expires</code> 或者 <code>Cache-Control</code> 这两个 <code>http response header</code> 实现的，它们都用来表示资源在客户端缓存的有效期。</p><h4 id="一，Expires"><a href="#一，Expires" class="headerlink" title="一，Expires"></a>一，Expires</h4><p><code>Expires</code> 是 <code>http1.0</code> 提出的一个表示资源过期时间的 <code>header</code>，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p><p>（1）浏览器第一次跟服务器请求一个资源的时候，服务器在返回这个资源的同时，会在 <code>response</code> 的 header 加上 <code>Expires</code> 的 <code>header</code>，如</p><p><img src="/images/expires.jpeg" alt="一，Expires"></p><p>（2）浏览器在接收到这个资源后，会把这个资源连同所有的 <code>response header</code> 一起缓存下来（所有缓存命中的请求返回的 <code>header</code> 并不是来自服务器，而是来自之前缓存的 <code>header</code>）</p><p>（3）浏览器再请求这个资源的时候，会先从缓存中去寻找，最好找到这个资源后，会拿当前的时间和Expire设置的时间比较，如果当前请求的时间在 <code>Expires</code> 指定的时间之前，那么就能命中缓存，否则不命中。</p><p>（4）如果缓存没有命中，那么浏览器直接从服务器中加载资源时，<code>Expire Header</code> 在重新加载的时候就会被更新。</p><p>  <strong>弊端：Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。</strong></p><p>所以在 <code>HTTP1.1</code> 的时候，就提出了一个新的header：<code>Cache-Control</code>，这是一个相对的时间，在配置缓存的时候以秒为单位，用数值表示，如：Cache-Control：max-age=315360000</p><h4 id="二，Cache-Control"><a href="#二，Cache-Control" class="headerlink" title="二，Cache-Control"></a>二，Cache-Control</h4><p>（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 <code>respone</code> 的 <code>header</code> 加上 <code>Cache-Control</code> 的 <code>header</code>，如：</p><p><img src="/images/cacheControl.png" alt="二，Cache-Control"></p><p>（2）浏览器在接收到这个资源后，会把这个资源连同所有 <code>response header</code> 一起缓存下来；</p><p>（3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 <code>Cache-Control</code> 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。（4）如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Cache-Control Header</code> 在重新加载的时候会被更新。</p><p><code>Cache-Control</code> 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。这两个header可以只启用一个，也可以同时启用，当<code>response header</code> 中，<code>Expires</code> 和 <code>Cache-Control</code> 同时存在时，<code>Cache-Control</code> 优先级高于<code>Expires</code>：</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个<code>Not Modified</code>的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看 <code>network</code>，可以看到有不少请求就是命中了协商缓存的：</p><p><img src="/images/304.png" alt="协商缓存"></p><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的</p><h4 id="一，【Last-Modified，If-Modified-Since】"><a href="#一，【Last-Modified，If-Modified-Since】" class="headerlink" title="一，【Last-Modified，If-Modified-Since】"></a>一，【Last-Modified，If-Modified-Since】</h4><p>（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，<strong>在respone的header加上 <code>Last-Modified</code> 的header</strong>，这个header表示这个资源在服务器上的最后修改时间：</p><p><img src="/images/lastModify.png" alt="Last-Modified"></p><p>（2）浏览器再次跟服务器请求这个资源时，<strong>在request的header上加上 <code>If-Modified-Since</code> 的header</strong>，这个header的值就是上一次请求时返回的<code>Last-Modified</code>的值：</p><p><img src="/images/ifModifySince.png" alt="If-Modified-Since"></p><p>（3）服务器再次收到资源请求时，根据浏览器传过来 <code>If-Modified-Since</code> 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加 <code>Last-Modified</code>的header，因为既然资源没有变化，那么 <code>Last-Modified</code> 也就不会改变，这是服务器返回304时的 `response header ：</p><p><img src="/images/header.png" alt="header"></p><p>（4）浏览器收到304的响应后，就会从缓存中加载资源。<br>（5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，<code>Last-Modified</code>Header在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code>会启用上次返回的<code>Last-Modified</code>值。</p><p>  <strong>弊端：【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。</strong></p><p>所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。</p><h4 id="二，【ETag、If-None-Match】"><a href="#二，【ETag、If-None-Match】" class="headerlink" title="二，【ETag、If-None-Match】"></a>二，【ETag、If-None-Match】</h4><p>（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上<code>ETag</code>的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个<strong>唯一标识是一个字符串</strong>，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：</p><p><img src="/images/etag.png" alt="Etag"></p><p>（2）浏览器再次跟服务器请求这个资源时，<strong><em>在request的header上加上<code>If-None-Match</code>的header，这个header的值就是上一次请求时返回的ETag的值</em></strong>：</p><p><img src="/images/ifNoMatch.png" alt="If-None-Match"></p><p>（3）服务器再次收到资源请求时，根据浏览器传过来<code>If-None-Match</code>和然后再根据资源生成一个新的<code>ETag</code>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：</p><p><img src="/images/etag2.png" alt="new Etag"></p><p>（4）浏览器收到304的响应后，就会从缓存中加载资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直对浏览器缓存只能描述一个大概，深层次的原理不能描述上来；为了泄恨，查阅一些资料最终对其有了一个更深入的理解&lt;/p&gt;
&lt;p&gt;本文主要讲解浏览器端的缓存，缓存的作用是不言而喻的，能够极大的改善网页性能，提高用户体验。&lt;/p&gt;
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>如何理解Javascript中的this</title>
    <link href="http://yoursite.com/2020/03/17/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3javascript%E4%B8%AD%E7%9A%84this/"/>
    <id>http://yoursite.com/2020/03/17/如何理解javascript中的this/</id>
    <published>2020-03-17T15:27:26.000Z</published>
    <updated>2020-03-21T10:16:58.218Z</updated>
    
    <content type="html"><![CDATA[<p>关于this指向的文章，网上一搜一大把，可是很多文章都是复制粘贴的水文，是否真正的了解JavaScript中的this，那就未必。那么我们应该如何简单轻松的理解this呢？</p><p>要简单轻松的理解this，就要记住一句话：<strong>this的指向并不是在函数定义的时候确定的，而是在其被调用的时候确定的</strong>。也就是说，<strong>this是在运行的时候基于函数的执行环境绑定的。</strong></p><p>this的指向可以分为5大类：</p><a id="more"></a><ul><li>纯粹的函数调用</li><li>作为对象的属性调用</li><li>作为构造函数调用</li><li>apply,call调用</li><li>箭头函数调用</li></ul><h3 id="一、-纯粹的函数调用"><a href="#一、-纯粹的函数调用" class="headerlink" title="一、 纯粹的函数调用"></a>一、 纯粹的函数调用</h3><p> 纯粹的函数调用，也就是最普遍的函数调用方式。非严格模式下，this指向的是window。严格模式下，this指向了undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 非严格模式下</span><br><span class="line">var a = 10;    // 全局变量相当于在window上面挂载属性a，window.a</span><br><span class="line">function func() &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();    // 10</span><br><span class="line"></span><br><span class="line">// 严格模式下</span><br><span class="line">var b = 10;</span><br><span class="line">function func1() &#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    console.log(this.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1();    // Uncaught TypeError: Cannot read property &apos;b&apos; of undefined</span><br></pre></td></tr></table></figure><h3 id="二、作为对象的属性调用"><a href="#二、作为对象的属性调用" class="headerlink" title="二、作为对象的属性调用"></a>二、作为对象的属性调用</h3><p>函数作为对象的属性调用时候，this 指向这个对象。（实际上纯粹的函数调用也可以算是作为对象的函数调用，因为全局变量是直接挂载在window上的，所以 func() 也就相当于 window.func() ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    func: func</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.func()    // this指向了obj，所以this.a会打印出10</span><br></pre></td></tr></table></figure><p>要注意的是，如果像下面这种情况，this 指向的是window的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    func: func</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func1 = obj.func</span><br><span class="line"></span><br><span class="line">func1()    // 20, this指向了window</span><br></pre></td></tr></table></figure><p>所以说还得看函数调用的位置。</p><h3 id="三、作为构造函数调用"><a href="#三、作为构造函数调用" class="headerlink" title="三、作为构造函数调用"></a>三、作为构造函数调用</h3><p>通过构造函数，可以生成一个新对象（这个也就是我们经常说的实例）。这时，this就指这个新对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Func() &#123;</span><br><span class="line">    this.a = 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = new Func()</span><br><span class="line">console.log(obj.a);    // 10</span><br></pre></td></tr></table></figure><p>使用new调用构造函数实际上会经历四个过程：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象。（this指向了新对象）</li><li>执行构造函数中的代码。（挂载属性）</li><li>返回新的对象</li></ol><p>如何手动实现new的功能？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function create() &#123;</span><br><span class="line">    // 创建一个新的对象</span><br><span class="line">    var obj = new Object(),</span><br><span class="line">    // 获得构造函数，arguments中去除第一个参数，Func指的是构造函数</span><br><span class="line">    Func = [].shift.call(arguments);</span><br><span class="line">    // 将构造函数的作用域赋给新对象。</span><br><span class="line">    obj.__proto__ = Func.prototype;</span><br><span class="line">    // 执行构造函数中的代码，使obj 可以访问到构造函数中的属性</span><br><span class="line">    var res = Func.apply(obj, arguments);</span><br><span class="line">    // 返回新的对象。判断构造函数的返回值是否是对象，如果是就返回。不是就返回新的对象。</span><br><span class="line">    return res instanceof Object ? res : obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Func() &#123;</span><br><span class="line">    this.a = 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用new</span><br><span class="line">var func1 = new Func()</span><br><span class="line">                        </span><br><span class="line">// 使用手写的new，即create</span><br><span class="line">var func2 = create(Func)</span><br><span class="line"></span><br><span class="line">console.log(func1, func2); // &#123;a: 20&#125;, &#123;a: 20&#125;</span><br></pre></td></tr></table></figure><h3 id="四、apply、call调用"><a href="#四、apply、call调用" class="headerlink" title="四、apply、call调用"></a>四、apply、call调用</h3><p>apply、call都是是函数的一个方法，作用是改变函数的调用对象。它们的第一个参数就表示改变后的调用这个函数的对象。this 指的就是这第一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 20</span><br><span class="line">&#125;</span><br><span class="line">function func() &#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj);    // 20</span><br><span class="line">func.apply(obj);    // 20</span><br></pre></td></tr></table></figure><p>不同的是，apply的第二个参数是一个数组或者类数组对象，而call的是指定的参数列表。</p><h3 id="五、箭头函数调用"><a href="#五、箭头函数调用" class="headerlink" title="五、箭头函数调用"></a>五、箭头函数调用</h3><p>箭头函数有两个作用，更简短的函数并且不绑定this。即箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承 this 。简单点来说，箭头函数的 this 会继承外层不为箭头函数的函数的 this</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 20;</span><br><span class="line">function func() &#123;</span><br><span class="line">    var fun1 = () =&gt; &#123;</span><br><span class="line">        console.log(this.a)</span><br><span class="line">    &#125;</span><br><span class="line">    return fun1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func()();    // 20，箭头函数fun1的this会从外层不为箭头函数的函数func继承而来。func的this指向了window，所以this.a是20</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于this指向的文章，网上一搜一大把，可是很多文章都是复制粘贴的水文，是否真正的了解JavaScript中的this，那就未必。那么我们应该如何简单轻松的理解this呢？&lt;/p&gt;
&lt;p&gt;要简单轻松的理解this，就要记住一句话：&lt;strong&gt;this的指向并不是在函数定义的时候确定的，而是在其被调用的时候确定的&lt;/strong&gt;。也就是说，&lt;strong&gt;this是在运行的时候基于函数的执行环境绑定的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;this的指向可以分为5大类：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-Javascript版-找出数组中的数字</title>
    <link href="http://yoursite.com/2020/03/17/%E5%89%91%E6%8C%87offer-javascript%E7%89%88-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/17/剑指offer-javascript版-找出数组中的数字/</id>
    <published>2020-03-17T13:56:26.000Z</published>
    <updated>2020-03-21T10:16:58.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对应LeetCode上的题目：面试题03. 数组中重复的数字</p></blockquote><p><strong>题目描述</strong>：在一个长度为 <code>n</code> 的数组 <code>nums</code> 里的所有数字都在 <code>0～n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 <code>n</code> 的数组 <code>nums</code> 里的所有数字都在 <code>0～n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字</p><h2 id="解法一，暴力求解法"><a href="#解法一，暴力求解法" class="headerlink" title="解法一，暴力求解法"></a>解法一，暴力求解法</h2><p>先把输入的数字排序，从排序的数字中找出重复的数字，即需要从头到尾扫描排序后的数组就可以了，排序一个长度为 <code>n</code> 的数组需要 <code>O(nlogn)</code> 的时间（排序最快的速度是 <code>O(nlogn)</code> ，即快速排序）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findRepeatNumber = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 先排序</span></span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 比较前后的值是否相同</span></span><br><span class="line">    <span class="keyword">if</span>(nums[i] === nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可想而知，这种解法并不是那么令人满意，因为需要先把数组排序</p><h2 id="解法二，使用对象"><a href="#解法二，使用对象" class="headerlink" title="解法二，使用对象"></a>解法二，使用对象</h2><p>使用对象来解决这个问题，从头到尾遍历整个数组，依次把数组的每一项当作对象的 <code>key</code> 值存进对象。如果数组的某个项在对象中存在，那么我们就可以认为这个值在数组中重复了，直接返回即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> findRepeatNumber = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用来存放是否遍历过的数组的项</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 数组的项是否已经是对象obj的键值了</span></span><br><span class="line">    <span class="keyword">if</span>(obj[nums[i]]) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[i]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[nums[i]] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法三，数学分析法"><a href="#解法三，数学分析法" class="headerlink" title="解法三，数学分析法"></a>解法三，数学分析法</h2><p>从头到尾遍历数组</p><ul><li><p>当数组下标为 <code>i</code> 的时候，比较这个数字（用 <code>m</code> 表示）是不是等于 <code>i</code>，如果是，则接着扫描下一个数字。</p></li><li><p>如果不是，拿它与第 <code>m</code> 个数字进行比较。如果它和第 <code>m</code> 个数字相等，就找到了一个重复的数组（<code>i</code> 和 <code>m</code> 的位置上都存在数字 <code>m</code>）。如果它和第 <code>m</code> 个数字不相等，就把第 <code>i</code> 个位置上的数字和第 <code>m</code> 个位置上的数字交换，那么 第 <code>m</code> 位上的数字就是 <code>m</code> 了</p></li><li><p>重复这个比较，直到发现一个重复的数字</p></li></ul><p><strong>[2, 3, 1, 0, 2, 5, 3] 举个例子：</strong></p><ul><li><p>首先遍历这个数组，从 <code>0</code> 位置上开始遍历。<code>0</code> 上面的数字是 <code>2</code>，那么我们可以直接拿数字 <code>2</code> 和 <code>2</code> 位置上的 <code>1</code> 做比较，结果不相等，交换位置。交换之后的数组是 <strong>[1, 3, 2, 0, 2, 5, 3]</strong></p></li><li><p>此时 <code>0</code> 位置上面的数字是 <code>1</code>，仍然不相等，继续和下标为 <code>1</code> 的 数字 <code>3</code> 做交换。交换之后的数组是 <strong>[3, 1, 2, 0, 2, 5, 3]</strong></p></li><li><p>此时 <code>0</code> 位置上面的数字是 <code>3</code>，仍然不相等，继续和下标为 <code>3</code> 的 数字 <code>0</code> 做交换。交换之后的数组是 <strong>[0, 1, 2, 3, 2, 5, 3]</strong></p></li><li><p>这时候 <code>0</code> 位置上的数字是 <code>0</code> 了，那么我们可以直接遍历下一个数字了，可知接下来的数字 <code>1</code>，<code>2</code>，<code>3</code> 都与坐标相等，不用进行交换操作。</p></li><li><p>接下来到位置 <code>4</code> 的数字 <code>2</code> ，由于数字与位置不相等，再比较位置 <code>2</code> 上的数字。发现位置 <code>2</code> 上的数字也是 <code>2</code> 了，因此我们便找到了一个重复的数字</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> findRepeatNumber = <span class="function">(<span class="params">nums</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(nums[i] !== i) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i] === nums[nums[i]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 交换数组两个位置上的项，这里是i 和 num[i] 交换</span></span><br><span class="line">      <span class="keyword">let</span> temp= nums[i]</span><br><span class="line">      nums[i] = nums[temp]</span><br><span class="line">      nums[temp] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对应LeetCode上的题目：面试题03. 数组中重复的数字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：在一个长度为 &lt;code&gt;n&lt;/code&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; 里的所有数字都在 &lt;code&gt;0～n-1&lt;/code&gt; 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>

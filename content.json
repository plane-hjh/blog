{"pages":[],"posts":[{"title":"剑指Offer-Javascript版-二维数组中的查找","text":"对应LeetCode上的题目：面试题04. 二维数组中的查找 题目描述：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法一，暴力求解法因为是 n * m 的二维数组，所以我们可以直接使用双层遍历来遍历整个二维数组的项。注意，该方法不管你数组是递增还是递减的规律，直接一梭子遍历就完事了 12345678910111213141516171819202122var findNumberIn2DArray = function(matrix, target) { // 多少行 const rowLength = matrix.length if(!rowLength) return false // 多少列 const colLength = matrix[0].length if(!colLength) return false for(let i = 0; i &lt; rowLength; i++) { for(let j = 0; j &lt; colLength; j++) { if(matrix[i][j] === target) { return true } } } return false}; 当然，我们也可以使用数组提供的 API 去解决这道问题，例如：indexOf，includes，但是由于该种做法过于简单，我们刷题的时候应该尽量避免使用此类 API，下面讲述一下思路： 遍历数组的每一个项，再使用数组的每一项去判断子数组中是否存在目标元素（indexOf 判断子数组中目标元素的位置，可以用是否大于 -1 来判断，includes 则是判断数组中是否存在某元素，存在则返回 true，否则返回 false） 解法二，发现规律从题目描述中可以发现二维数组中的每一行都按照从左到右递增，每一列都按照从上到下递增。我们可以利用这一规律作为解题的突破口，那么 从数组中选取一个数组，分三种情况来分析查找的过程 如果数组中选取的数字刚好等于目标元素，那么直接返回 true，结束查找。 如果选取的数字小于目标元素，那么目标元素的位置应该在选取的数字的右边或者下边 同样，如果选取的数字大于目标元素，那么目标元素的位置应该在选取的数字的左边或者上边 1234567891011121314151617181920212223242526272829var findNumberIn2DArray = function(matrix, target) { const rowLength = matrix.length if(!rowLength) { return false } const colLength = matrix[0].length if(!colLength) { return false } let row = 0, col = colLength - 1; while(row &lt; rowLength &amp;&amp; col &gt;= 0) { if(matrix[row][col] === target) { // 第一种情况 return true } else if(matrix[row][col] &gt; target) { // 第三种情况 --col } else { // 第二种情况 ++row } } return false};","link":"/blog/2020/03/18/剑指offer-javascript版-二维数组中的查找/"},{"title":"剑指Offer-Javascript版-找出数组中的数字","text":"对应LeetCode上的题目：面试题03. 数组中重复的数字 题目描述：在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字 题目描述在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字 解法一，暴力求解法先把输入的数字排序，从排序的数字中找出重复的数字，即需要从头到尾扫描排序后的数组就可以了，排序一个长度为 n 的数组需要 O(nlogn) 的时间（排序最快的速度是 O(nlogn) ，即快速排序） 1234567891011const findRepeatNumber = (nums) =&gt; { // 先排序 nums.sort((a, b) =&gt; a - b) for(let i = 0, len = nums.length; i &lt; len-1; i++) { // 比较前后的值是否相同 if(nums[i] === nums[i+1]) { return nums[i] } }} 可想而知，这种解法并不是那么令人满意，因为需要先把数组排序 解法二，使用对象使用对象来解决这个问题，从头到尾遍历整个数组，依次把数组的每一项当作对象的 key 值存进对象。如果数组的某个项在对象中存在，那么我们就可以认为这个值在数组中重复了，直接返回即可 12345678910111213const findRepeatNumber = (nums) =&gt; { // 用来存放是否遍历过的数组的项 const obj = {} for(let i = 0; i &lt; nums.length; i++) { // 数组的项是否已经是对象obj的键值了 if(obj[nums[i]]) { return nums[i] } else { obj[nums[i]] = 1 } }} 解法三，数学分析法从头到尾遍历数组 当数组下标为 i 的时候，比较这个数字（用 m 表示）是不是等于 i，如果是，则接着扫描下一个数字。 如果不是，拿它与第 m 个数字进行比较。如果它和第 m 个数字相等，就找到了一个重复的数组（i 和 m 的位置上都存在数字 m）。如果它和第 m 个数字不相等，就把第 i 个位置上的数字和第 m 个位置上的数字交换，那么 第 m 位上的数字就是 m 了 重复这个比较，直到发现一个重复的数字 [2, 3, 1, 0, 2, 5, 3] 举个例子： 首先遍历这个数组，从 0 位置上开始遍历。0 上面的数字是 2，那么我们可以直接拿数字 2 和 2 位置上的 1 做比较，结果不相等，交换位置。交换之后的数组是 [1, 3, 2, 0, 2, 5, 3] 此时 0 位置上面的数字是 1，仍然不相等，继续和下标为 1 的 数字 3 做交换。交换之后的数组是 [3, 1, 2, 0, 2, 5, 3] 此时 0 位置上面的数字是 3，仍然不相等，继续和下标为 3 的 数字 0 做交换。交换之后的数组是 [0, 1, 2, 3, 2, 5, 3] 这时候 0 位置上的数字是 0 了，那么我们可以直接遍历下一个数字了，可知接下来的数字 1，2，3 都与坐标相等，不用进行交换操作。 接下来到位置 4 的数字 2 ，由于数字与位置不相等，再比较位置 2 上的数字。发现位置 2 上的数字也是 2 了，因此我们便找到了一个重复的数字 123456789101112131415const findRepeatNumber = (nums) =&gt; { for(let i = 0; i &lt; nums.length; i++) { while(nums[i] !== i) { if(nums[i] === nums[nums[i]]) { return nums[i] } // 交换数组两个位置上的项，这里是i 和 num[i] 交换 let temp= nums[i] nums[i] = nums[temp] nums[temp] = temp } }}","link":"/blog/2020/03/17/剑指offer-javascript版-找出数组中的数字/"},{"title":"前端各种源码实现","text":"在面试中，面试官多多少少都会要求面试者手写几道手写代码方法，这时候，不仅要求面试者能够熟练使用用这个方法，更是要求面试者对这个方法的原理。 实现一个 new 操作符 实现一个 instanceof 实现一个浅拷贝或者深拷贝 实现 call 和 apply 实现 防抖 和 节流 实现一个 promise 实现一个 new 操作符要创建一个实例，那么必须要使用 new 操作符。使用 new 操作符内部会经历4个过程 创建一个新的对象 将构造函数的作用域赋给了新对象 执行构造函数中的代码 返回新的对象（注意：如果构造函数中有返回对象类型的值，那么我们就直接返回这个对象。否则返回新的对象） 123456789101112131415function createNew(fn) { // 1. 创建一个新的对象 let obj = new Object() // 2. 将构造函数的作用域赋给了新对象 if(fn.prototype) { obj.__proto__ = fn.prototype } // 3. 执行构造函数中的代码 const result = fn.apply(obj, [...arguments].slice(1)) // 4. 返回新的对象 return typeof result === 'object' ? result : obj} 实现一个 instanceofinstanceof 可以正确的判断对象的类型。因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype 12345678910111213141516171819// letf 对象// right 类型const instanceof = (left, right) =&gt; { // 类型的原型 let prototype = right.prototype // 对象的原型 let proto = left.__proto__ while(true) { if(proto === null) return false if(proto === prototype) return true proto = proto.__proto__ } return false} 实现一个浅拷贝或者深拷贝在使用对象的时候，我们经常会碰到这样的一个问题 12345678const a = { name: 'xiaohong'}const b = aa.name = 'xiaoming'console.log(b) // {name: 'xiaoming'} 可能会有朋友会问，咦，我们不是没有修改对象 b 的属性吗，怎么属性 name 变了。其实这里面涉及到引用类型的问题。对象是属于引用类型，把对象赋值给另外一个变量，实际上是把对象的指针指向的内存地址共享给了变量。对象和变量共享同一份内存地址。那么 a 的属性改变了，那么 b 的也会跟着变化的。这时候为了避免这种情况发生，我们可以使用 浅拷贝 来进行操作 Object.assign 12345678const a = { name: 'xiaohong'}const b = Object.assign({}, a)a.name = 'xiaoming'console.log(b) // {name: 'xiaohong'} 对象展开运算符 12345678const a = { name: 'xiaohong'}const b = {...a}a.name = 'xiaoming'console.log(b) // {name: 'xiaohong'} 注意，浅拷贝 避免对象内部的属性不是引用类型的情况，那么如果对象的内部属性仍然是引用类型的情况时，浅拷贝 这时候只会对对象最外层生效了 1234567891011const a = { name: 'xiaohong', obj: { age: 10 }}const b = Object.assign({}, a)a.obj.age = 20console.log(b) // {name: 'xiaohong',obj:{age: 20}} 浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入 深拷贝 的概念了。 一般来说，使用 JSON.parse(JSON.stringify()) 已经满足了 1var newObj = JSON.parse( JSON.stringify( someObj ) ); 但是这种方法存在局限性 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 所以，我们可以利用递归来解决这种情况 1234567891011121314function deepCopy(obj){ //判断是否是简单数据类型， if(typeof obj == \"object\"){ //复杂数据类型 var result = obj.constructor == Array ? [] : {}; for(let i in obj){ result[i] = typeof obj[i] == \"object\" ? deepCopy(obj[i]) : obj[i]; } }else { //简单数据类型 直接 == 赋值 var result = obj; } return result;} 实现 call 和 applycall 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。与 apply 方法类似，只有一个区别，就是 call 方法接受的是一个参数列表，而 apply 方法接受的是一个包含多个参数的数组。 123456789101112Fuction.prototype.myCall = (content) =&gt; { content = content || window content.fn = this let args = [...arguments].slice(1) let res = content.fn(...args) delete content.fn return res} 同理，apply 的实现只是传入的参数是一个数组而已 12345678910111213141516Fuction.prototype.myApply = (content) =&gt; { content = content || window content.fn = this let res if(argument[1]) { res = content.fn(...arguments[1]) } else { res = content.fn() } delete content.fn return res} 实现 防抖 和 节流防抖 指的是防止用户用户过多操作，而带来不必要的性能耗费，把操作改成最后一次执行，只要用户有操作，事件行为也会一直被推迟。例如输入框 1234567891011121314const debounce = function (wait, fn) { let timer return (...args) =&gt; { // 如果事件一直在触发，那么就把上一次事件的定时器清除 if(timer) { clearTimeOut(timer) } timer = setTimeout(() =&gt; { fn.apply(this, args) }, wait) }} 防抖 和 节流 本质是不一样的。防抖 是将多次执行变为最后一次执行，节流 是将多次执行变成每隔一段时间执行。 1234567891011121314const throttle = function (wait, fn) { let preTime = 0 return (...args) =&gt; { // 获取当前的时间戳 let curTime = new Date().getTime() // 与上一个时间段的时间戳做对比 if((curTime - preTime) &gt; wait) { preTime = curTime fn.apply(this, args) } }} 实现一个promise（1）”promise”是一个对象或者函数，该对象或者函数有一个then方法 （2）”then”是一个对象或者函数，用来定义then方法 （3）”value”是promise状态成功时的值 （4）”reason”是promise状态失败时的值 普通版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function myPromise(constructor) { let self = this // 一个promise必须有3个状态，pending，fulfilled(resolved) self.status = \"pending\" // 定义状态改变前的初始状态 self.value = undefined // 定义状态为resolve的时候的状态 self.reason = undefined // 定义状态为reject的时候的状态 function resolve () { // 两个pending，保证了状态的改变是不可逆的 if(selft.status === 'pending') { self.value = value self.status = \"resolved\" } } function reject () { // 两个pending，保证了状态的改变是不可逆的 if(selft.status === 'pending') { self.reason = reason self.status = \"rejectd\" } } //捕获构造异常 try{ constructor(resolve, reject) } catch(e) { reject(e) }}// 一个promise必须有一个then方法，then方法接受两个参数myPromise.prototype.then = function(onFullfilled, onRejected) { let self = this switch(self.status) { case \"resolved\": onFullfilled(self.value) break case \"rejected\": onRejected(self.value) break default }} 但是这里 myPromise 无法处理异步的 resolve. 比如： 123456789var p= new myPromise(function(resolve,reject){ setTimeout(function(){ resolve(1) },1000)});p.then(function(x){ console.log(x)}) 而且 myPromise 也没有实现链式调用，也就是说 then 方法返回的应该是一个 promise。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 为了处理异步resolve，我们修改myPromise的定义，用2个数组onFullfilledArray和onRejectedArray来保存异步的方法。在状态发生改变时，一次遍历执行数组中的方法。function myPromise(constructor){ let self=this; self.status=\"pending\" //定义状态改变前的初始状态 self.value=undefined;//定义状态为resolved的时候的状态 self.reason=undefined;//定义状态为rejected的时候的状态 self.onFullfilledArray=[]; self.onRejectedArray=[]; function resolve(value){ if(self.status===\"pending\"){ self.value=value; self.status=\"resolved\"; self.onFullfilledArray.forEach(function(f){ f(self.value); //如果状态从pending变为resolved， //那么就遍历执行里面的异步方法 }); } } function reject(reason){ if(self.status===\"pending\"){ self.reason=reason; self.status=\"rejected\"; self.onRejectedArray.forEach(function(f){ f(self.reason); //如果状态从pending变为rejected， //那么就遍历执行里面的异步方法 }) } } //捕获构造异常 try{ constructor(resolve,reject); }catch(e){ reject(e); }}// 要通过then方法实现链式调用，那么也就是说then方法每次调用需要返回一个primise,同时在返回promise的构造体里面，增加错误处理部分，我们来改造then方法myPromise.prototype.then=function(onFullfilled,onRejected){ let self=this; let promise2; switch(self.status){ case \"pending\": promise2=new myPromise(function(resolve,reject){ self.onFullfilledArray.push(function(){ try{ let temple=onFullfilled(self.value); resolve(temple) }catch(e){ reject(e) //error catch } }); self.onRejectedArray.push(function(){ try{ let temple=onRejected(self.reason); reject(temple) }catch(e){ reject(e)// error catch } }); }) case \"resolved\": promise2=new myPromise(function(resolve,reject){ try{ let temple=onFullfilled(self.value); //将上次一then里面的方法传递进下一个Promise的状态 resolve(temple); }catch(e){ reject(e);//error catch } }) break; case \"rejected\": promise2=new myPromise(function(resolve,reject){ try{ let temple=onRejected(self.reason); //将then里面的方法传递到下一个Promise的状态里 resolve(temple); }catch(e){ reject(e); } }) break; default: } return promise2;}","link":"/blog/2020/03/24/前端面试-手写代码秘籍/"},{"title":"剑指Offer-Javascript版-替换空格","text":"对应LeetCode上的题目：面试题05. 替换空格 题目描述：请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 例： 12输入：s = \"We are happy.\"输出：\"We%20are%20happy.\" 题目描述请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 例： 12输入：s = \"We are happy.\"输出：\"We%20are%20happy.\" 解法一，正则表达式字符串有一个 replace 方法，可以把字符串里面特定的字符转换成我们想要的字符 123456var replaceSpace = function(s) { if(!s) return return s.replace(/ /g, '%20')}; 一句代码就搞定，这方法真香 解法二使用字符串的分割 split 和 数组的分割 join 123456var replaceSpace = function(s) { if(!s) return return s.spilt(' ').join('%20')}; 注意，虽然这种 api 是香，但是只能作为一种辅助的方法，面试官更多想考我们的算法能力和解题思路，这种只能用来当作题目的一种解法 解法三，双指针遍历原字符串，统计空格和非空格字符个数，计算替换后的新字符的长度，准备两个指针，指针 i 指向原字符串，指针 j 指向新字符串 123456789101112131415161718192021222324252627282930313233var replaceSpace = function(s) { if(!s || !s.length) { return \"\" } // emptyNum 空格的个数 // chNum 非空字符的个数 let emptyNum = 0, chNum = 0; for(let i = 0, len = s.length; i &lt; len; i++) { if(s[i] === ' ') { ++emptyNum } else { ++chNum } } const length = emptyNum * 2 + chNum const chs = new Array(length) // i 是新字符串的下标，j是源字符串的下标 for(let i = 0, j = 0; j &lt; s.length; ++j) { if(s[j] === \" \") { chs[i++] = \"%\" chs[i++] = \"2\" chs[i++] = \"0\" } else { chs[i++] = s[j] } } return chs.join(\"\")}","link":"/blog/2020/03/18/剑指offer-javascript版-替换空格/"},{"title":"剑指Offer-Javascript版-斐波那契数列","text":"题目描述：写一个函数，输入n，求斐波那契数列的第n项。斐波那契数列的定义如下： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 题目描述写一个函数，输入n，求斐波那契数列的第n项。斐波那契数列的定义如下： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 解法一，递归由题目描述可以知道，斐波那契数列的第一项是 0，第一项是 1 ，第 n 项是第 n-1 和第 n-2的和，那么我们就可以下手了 12345678// 递归const fib = (n) =&gt; { if(n === 0) return 0 if(n === 1) return 1 return fib(n - 1) + fib(n - 2)} 解法二，递归+备忘录使用递归来解这道题可以说是相当简单了，但是有时候面试官并不想看到我们单纯的使用递归去解这一道题，因为计算量太多重复的了。例如我们在计算 n=9 的时候。 123f(9) = f(8) + f(7)那么f(8) = f(7) + f(6) 可以知道f(7) 被计算了两次，以此类推可以知道，我们在计算 f(9) 的时候，重复了太多了计算量了。那么我们可以使用 备忘录 的解法把已经计算过的值保存下来，下次如果再计算相同的值的时候，直接从备忘录里面取就可以了 123456789101112131415161718// 在动态规划的一种做法中，可以借助“备忘录”来实现结果的缓存，避免重复计算const fib = (n) =&gt; { // 备忘录 const cache = { 0: 0, 1: 1 }; return Fibonacci(n); function Fibonacci(n) { if (cache[n] !== undefined) { return cache[n]; } cache[n] = Fibonacci(n - 1) + Fibonacci(n - 2); return cache[n]; }}; 解法三，循环+备忘录我们也可以使用循环来替代递归 123456789101112131415161718192021222324const fib = (n) =&gt; { // 备忘录 const cache = { 0: 0, 1: 1 }; if(n &lt; 2) { return cache[n] } let fibNone = 1 let fibNtwo = 0 let fibN = 0 for(let i = 2; i &lt;= n; i++) { fibN = fibNone + fibNtwo fibNtwo = fibNone fibNone = fibN } return fibN}; 扩展类似题目： 青蛙跳台阶问题 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。","link":"/blog/2020/03/22/剑指offer-javascript版-斐波那契数列/"},{"title":"剑指Offer-Javascript版-二叉树的下一个节点","text":"题目描述：给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点除了有两个分别指向左，右子节点的指针，还有一个指向父节点的指针","link":"/blog/2020/03/22/剑指offer-javascript版-二叉树的下一个节点/"},{"title":"如何理解Javascript中的this","text":"关于this指向的文章，网上一搜一大把，可是很多文章都是复制粘贴的水文，是否真正的了解JavaScript中的this，那就未必。那么我们应该如何简单轻松的理解this呢？ 要简单轻松的理解this，就要记住一句话：this的指向并不是在函数定义的时候确定的，而是在其被调用的时候确定的。也就是说，this是在运行的时候基于函数的执行环境绑定的。 this的指向可以分为5大类： 纯粹的函数调用 作为对象的属性调用 作为构造函数调用 apply,call调用 箭头函数调用 一、 纯粹的函数调用 纯粹的函数调用，也就是最普遍的函数调用方式。非严格模式下，this指向的是window。严格模式下，this指向了undefined。 1234567891011121314151617// 非严格模式下var a = 10; // 全局变量相当于在window上面挂载属性a，window.afunction func() { &quot;use strict&quot;; console.log(this.a);}func(); // 10// 严格模式下var b = 10;function func1() { &quot;use strict&quot;; console.log(this.b);}func1(); // Uncaught TypeError: Cannot read property &apos;b&apos; of undefined 二、作为对象的属性调用函数作为对象的属性调用时候，this 指向这个对象。（实际上纯粹的函数调用也可以算是作为对象的函数调用，因为全局变量是直接挂载在window上的，所以 func() 也就相当于 window.func() ） 1234567891011var a = 20;var obj = { a: 10, func: func}function func() { console.log(this.a);}obj.func() // this指向了obj，所以this.a会打印出10 要注意的是，如果像下面这种情况，this 指向的是window的 12345678910111213var a = 20;var obj = { a: 10, func: func}function func() { console.log(this.a);}var func1 = obj.funcfunc1() // 20, this指向了window 所以说还得看函数调用的位置。 三、作为构造函数调用通过构造函数，可以生成一个新对象（这个也就是我们经常说的实例）。这时，this就指这个新对象。 123456function Func() { this.a = 10;}var obj = new Func()console.log(obj.a); // 10 使用new调用构造函数实际上会经历四个过程： 创建一个新对象 将构造函数的作用域赋给新对象。（this指向了新对象） 执行构造函数中的代码。（挂载属性） 返回新的对象 如何手动实现new的功能？ 123456789101112131415161718192021222324function create() { // 创建一个新的对象 var obj = new Object(), // 获得构造函数，arguments中去除第一个参数，Func指的是构造函数 Func = [].shift.call(arguments); // 将构造函数的作用域赋给新对象。 obj.__proto__ = Func.prototype; // 执行构造函数中的代码，使obj 可以访问到构造函数中的属性 var res = Func.apply(obj, arguments); // 返回新的对象。判断构造函数的返回值是否是对象，如果是就返回。不是就返回新的对象。 return res instanceof Object ? res : obj;};function Func() { this.a = 20;}// 使用newvar func1 = new Func() // 使用手写的new，即createvar func2 = create(Func)console.log(func1, func2); // {a: 20}, {a: 20} 四、apply、call调用apply、call都是是函数的一个方法，作用是改变函数的调用对象。它们的第一个参数就表示改变后的调用这个函数的对象。this 指的就是这第一个参数。 123456789var obj = { a: 20}function func() { console.log(this.a);}func.call(obj); // 20func.apply(obj); // 20 不同的是，apply的第二个参数是一个数组或者类数组对象，而call的是指定的参数列表。 五、箭头函数调用箭头函数有两个作用，更简短的函数并且不绑定this。即箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承 this 。简单点来说，箭头函数的 this 会继承外层不为箭头函数的函数的 this 123456789var a = 20;function func() { var fun1 = () =&gt; { console.log(this.a) } return fun1}func()(); // 20，箭头函数fun1的this会从外层不为箭头函数的函数func继承而来。func的this指向了window，所以this.a是20","link":"/blog/2020/03/17/如何理解javascript中的this/"},{"title":"强缓存和协商缓存","text":"之前一直对浏览器缓存只能描述一个大概，深层次的原理不能描述上来；为了泄恨，查阅一些资料最终对其有了一个更深入的理解 本文主要讲解浏览器端的缓存，缓存的作用是不言而喻的，能够极大的改善网页性能，提高用户体验。 浏览器缓存的基本认识分为强缓存 和 协商缓存 （1）浏览器在加载资源的时候，会根据HTTP的头部header判断它是否命中强缓存，强缓存如果直接命中，那么浏览器就会直接从自己的缓存中读取资源，而不会请求到服务器。比如某个css文件，如果浏览器在加载这个文件的时候，从这个文件的http头部判断命中了缓存，那么就会直接从内存中读取这个css文件，而不会再去请求服务器。 （2）当强缓存没有命中的时候，那么浏览器就会发送http请求到服务器，通过服务器依据资源的另外一些http头部去验证这个资源是否命中协商缓存，如果协商缓存命中，服务器就将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器可以直接从缓存中读取这个资源，那么浏览器就会从缓存中读取这个资源。 （3）强缓存和协商缓存的共同点：如果命中，那么都会从客户端的缓存中去读取资源，而不是从服务器中读取资源。不同的是，强缓存不会发送请求到服务器，而协商缓存则需要发送请求到服务器。 （4）如果协商缓存也没有命中的时候，浏览器直接从服务器中加载资源数据。 强缓存当浏览器对某个资源的请求命中了强缓存时，返回的 http 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache。 强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。 一，ExpiresExpires 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是： （1）浏览器第一次跟服务器请求一个资源的时候，服务器在返回这个资源的同时，会在 response 的 header 加上 Expires 的 header，如 （2）浏览器在接收到这个资源后，会把这个资源连同所有的 response header 一起缓存下来（所有缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header） （3）浏览器再请求这个资源的时候，会先从缓存中去寻找，最好找到这个资源后，会拿当前的时间和Expire设置的时间比较，如果当前请求的时间在 Expires 指定的时间之前，那么就能命中缓存，否则不命中。 （4）如果缓存没有命中，那么浏览器直接从服务器中加载资源时，Expire Header 在重新加载的时候就会被更新。 弊端：Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。 所以在 HTTP1.1 的时候，就提出了一个新的header：Cache-Control，这是一个相对的时间，在配置缓存的时候以秒为单位，用数值表示，如：Cache-Control：max-age=315360000 二，Cache-Control（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如： （2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来； （3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。（4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。 Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。这两个header可以只启用一个，也可以同时启用，当response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于Expires： 协商缓存当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的： 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的 一，【Last-Modified，If-Modified-Since】（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上 Last-Modified 的header，这个header表示这个资源在服务器上的最后修改时间： （2）浏览器再次跟服务器请求这个资源时，在request的header上加上 If-Modified-Since 的header，这个header的值就是上一次请求时返回的Last-Modified的值： （3）服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加 Last-Modified的header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回304时的 `response header ： （4）浏览器收到304的响应后，就会从缓存中加载资源。（5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-ModifiedHeader在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。 弊端：【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。 所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。 二，【ETag、If-None-Match】（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题： （2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值： （3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化： （4）浏览器收到304的响应后，就会从缓存中加载资源。","link":"/blog/2020/03/18/浏览器缓存/"},{"title":"树","text":"想普及一下树的知识，个人认为树是算法必须要牢牢掌握的一部分。 一般树的逻辑可以说是灰常滴简单了： 除根节点之外的每个节点只有一个父节点，根节点没有父节点。 除叶节点之外所有节点都有一个或多个子节点，叶节点没有子节点。 父节点和子节点之间是用指针连接，所以树会涉及到大量的指针，因此与树有关的面试题都不太容易，但是越不容易的知识点，我们就越要攻克。 树的遍历但是面试时候提到的树，大部分都是二叉树。二叉树是树的一种特殊结构，在二叉树中每个节点最多只能有两个子节点。在二叉树中最重要的考点莫过于树的遍历，即按照某一个顺序遍历访问树中的所有节点。 二叉树的遍历可以有以下几种： 前序遍历 中序遍历 后序遍历 层序遍历 但是从更宏观的角度来说，也可以归结为两大类 深度优先遍历（前序遍历，中序遍历，后序遍历） 广度优先遍历（层序遍历） 深度优先遍历和层次优先遍历这两个概念可不局限于二叉树，更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树，图，或其他一些复杂数据结构时，这两个概念常常被使用到。 深度优先遍历所谓深度优先，顾名思义，就是偏向于纵深，“一头扎到底”的访问方 式。即先访问树的根节点，再访问根节点的子节点，先往深层访问，深层访问节点结束了，再返回访问同层节点，之后再继续往深层访问节点…可能这种说法有些抽象，下面就通过二叉树的前序遍历、中序遍 历、后序遍历 ，来看一看深度优先是怎么回事吧。 前序遍历 前序遍历：先访问根节点，再访问左节点，最后访问右节点 12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归版本const preOrderTraverse = (root) =&gt; { let list = [] const preOrder = (node) =&gt; { if(node !== null) { // 先访问根节点 list.push(node.val) // 再访问左节点 preOrder(node.left) // 最后访问右节点 preOrder(node.right) } } inOrder(root) return list}// 非递归版本const preOrderTraverseUnRecur = (root) =&gt; { let list = []; let stack = [root]; while(stack.length !== 0) { const curNode = stack.pop() const left = curNode.left const right = curNode.right // 第一步的时候，先访问的是根节点 list.push(curNode.val) if(right) { stack.push(right) } // 因为pop是取出最后一个元素，所以我们要确保首先拿到的是左节点 if(left) { stack.push(left) } }} 中序遍历 中序遍历：先访问左节点，再访问中节点，最后访问右节点 123456789101112131415161718192021222324252627282930313233343536373839// 递归版本const inOrderTraverse = (root) =&gt; { let list = [] const inOrder = (node) =&gt; { if(node !== null) { inOrder(node.left) list.push(node.val) inOrder(node.right) } } inOrder(root) return list}// 非递归版本const inOrderTraverseUnRecur = (root) =&gt; { let list = [] // 借助了栈，先进后出的概念 let stack = [] let head = root while(stack.length !== 0 || head !== undefined) { while(head !== undefined) { stack.push(head) head = head.left } if(stack.length !== 0) { head = stack.pop() list.push(head.val) head = head.right } } return list} 后序遍历 后序遍历：先访问左节点，再访问右节点，最后访问根节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 递归const postOrderTraverse = (root) =&gt; { let list = [] const postOrder = (node) =&gt; { if(!node) { postOrder(node.left) postOrder(node.right) list.push(node.val) } } postOrder(root) return list}// 非递归const postOrderTraverseUnRecur = (root) =&gt; { let list = [] if(root !== undefined) { let s1 = [] let s2 = [] s1.push(root) while(s1.length !== 0) { head = s1.pop() s2.push(head) if(head.left !== undefined) { s1.push(head.left) } if(head.right !== undefined) { s1.push(head.right) } } while(s2.length !== 0) { var item = s2.pop() list.push(item.val) } } return list} 为了方便记忆，可以这样记：前序遍历对应的前是根节点最先访问。中序遍历对应的前是根节点放在中间访问。后序遍历对应的前是根节点最后才访问。 这三种遍历方式都有 递归 和 循环 两种不同的实现方式，但是面试官更喜欢考我们的是循环实现方式，所以我们应该要掌握这三种遍历的六种遍历方式! 广度优先遍历如果说深度优先遍历是在一个方向上“一头扎到底”，那么广度优先遍历 则恰恰相反: 先在各个方向上各走出1步，再在各个方向上走出第2步、 第3步……一直到各个方向全部走完。听起来有些抽象，下面让我们通 过二叉树的层序遍历 ，来看一看广度优先是怎么回事。 层序遍历层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关 系，一层一层横向遍历各个节点。 123456789101112131415161718// 层序遍历const levelOrderTraverse = (root) =&gt; { let queue = [root] let list = [] while(queue.length !== 0) { let node = queue.shift() list.push(node.val) if(node.left !== null) { queue.push(node.left) } if(node.right !== null) { queue.push(node.right) } }} 二叉搜索树二叉搜索树：左子节点总是小于或等于根节点，而右节点总是大于或等于根节点。可以在 O(logn) 内根据数值在二叉搜索树中找到一个节点 堆堆：分为最大堆和最小堆。最大堆中根节点的值最大，在最小堆中根节点的值最小。需要快速找到最大值或最小值都可以用堆来解决 红黑树红黑树：把树中的节点定义为红，黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍","link":"/blog/2020/03/21/树/"},{"title":"剑指Offer-Javascript版-用两个栈实现队列","text":"题目描述：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 1234输入：[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"][[],[3],[],[]]输出：[null,null,3,-1] 示例 2： 1234输入：[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 题目描述用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 1234输入：[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"][[],[3],[],[]]输出：[null,null,3,-1] 示例 2： 1234输入：[\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 解法1234567891011121314151617181920212223242526272829303132/** * outStack 不为空：弹出元素 * outStack 为空：将 inStack 元素依次弹出，放入到 outStack 中（在数据转移过程中，顺序已经从后入先出变成了先入先出） */var CQueue = function() { this.inStack = [] this.outStack = []};/** * @param {number} value * @return {void} */CQueue.prototype.appendTail = function(value) { this.inStack.push(value)};/** * @return {number} */CQueue.prototype.deleteHead = function() { const { inStack, outStack} = this // 如果要出的栈内没有元素，那么直接先把入栈内的元素，添加到出栈。然后再删除 if(!outStack.length) { while(inStack.length) { outStack.push(inStack.pop()) } } return outStack.pop() || -1};","link":"/blog/2020/03/22/剑指offer-javascript版-用两个栈实现队列/"},{"title":"剑指Offer-Javascript版-从尾到头打印链表","text":"对应LeetCode上的题目：面试题06. 从尾到头打印链表 题目描述：输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下： 1234function ListNode(val) { this.val = val; this.next = null;} 题目描述输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下： 1234function ListNode(val) { this.val = val; this.next = null;} 解法一，使用栈不改变链表的前提下。 遍历链表的顺序都是从头到尾，但是输出的顺序是从尾到头，也就是说第一个遍历的节点最后一个输出，最后一个遍历的节点第一个输出。这个不就是后进先出 吗？那么我们可以使用 栈 来实现这种做法。 每经过一个节点的时候，就把该节点放到一个栈中，当遍历完整个链表后。再从栈顶逐个输出节点的值 12345678910111213141516const printReverseListNode = (head) =&gt; { if (!head) return [] // 栈用来存放已经遍历过的数组 const stack = [] let curNode = head while(curNode) { stack.push(curNode.val) curNode = curNode.next } return stack.reverse()} 可见，使用栈来解决这类问题，是非常的简单。但是我们也要熟知栈的各种概念，我们才能在解题的时候游刃有余，一点都不慌。 当然啦，我们也可以使用递归来实现这种解法 1234567891011121314151617const printReverseListNode = (head) =&gt; { if (!head) return [] const stack =[] const getReverseListNode = (head) =&gt; { if(head) { if(head.next !== null) { printReverseListNode(head.next) } stack.push(head.val) } } getReverseListNode(head) return stack}","link":"/blog/2020/03/19/剑指offer-javascript版-从尾到头打印链表/"},{"title":"剑指Offer-Javascript版-重建二叉树","text":"对应LeetCode上的题目：面试题07. 重建二叉树 题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例子 1234567891011给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解法：二叉树的前序遍历和中序遍历二叉树的前序遍历中，第一个数字是二叉树的根节点。在中序遍历中，根节点位于序列的中间，即根节点的左边是左子树节点的值，右边是右子树节点的值。 由前序遍历 [3,9,20,15,7] 可知，3 是根节点。中序遍历 [9,3,15,20,7] 可知，根节点 3 的左边是左子树节点 9，右边是右子树节点 15，20，7。所以 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */var buildTree = function(preorder, inorder) { if(!preorder.length || !inorder.length) { return null } const rootVal = preorder[0] const node = new TreeNode(rootVal) // i有两个含义，一个是根节点在中序遍历结果中的下标， 另一个是当前左子树的节点个数 let i = 0; for(; i &lt; inorder.length; ++i) { if(inorder[i] === rootVal) { break; } } // i主要是求出根节点在中序遍历序列中的位置。那么i位置前面的都是左子树的值，后边的都是右子树的值。 // 中序遍历和前序遍历的左子树和右子树节点的个数都分别相等 // preorder.slice(1, i+1) 在前序遍历里面，左节点有多少个 // inorder.slice(0, i) 在中序遍历里面，左节点就是根节点位置i前面的那些 node.left = buildTree(preorder.slice(1, i+1), inorder.slice(0, i)) node.right = buildTree(preorder.slice(i+1), inorder.slice(i + 1)) return node}; 知识扩展","link":"/blog/2020/03/19/剑指offer-javascript版-重建二叉树/"}],"tags":[{"name":"数组","slug":"数组","link":"/blog/tags/数组/"},{"name":"字符串","slug":"字符串","link":"/blog/tags/字符串/"},{"name":"递归","slug":"递归","link":"/blog/tags/递归/"},{"name":"二叉树","slug":"二叉树","link":"/blog/tags/二叉树/"},{"name":"javascript","slug":"javascript","link":"/blog/tags/javascript/"},{"name":"http","slug":"http","link":"/blog/tags/http/"},{"name":"缓存","slug":"缓存","link":"/blog/tags/缓存/"},{"name":"树","slug":"树","link":"/blog/tags/树/"},{"name":"栈","slug":"栈","link":"/blog/tags/栈/"},{"name":"队列","slug":"队列","link":"/blog/tags/队列/"},{"name":"链表","slug":"链表","link":"/blog/tags/链表/"}],"categories":[{"name":"算法","slug":"算法","link":"/blog/categories/算法/"},{"name":"javascript","slug":"javascript","link":"/blog/categories/javascript/"},{"name":"http","slug":"http","link":"/blog/categories/http/"}]}
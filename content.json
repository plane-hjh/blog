{"pages":[],"posts":[{"title":"剑指Offer-Javascript版-二维数组中的查找","text":"对应LeetCode上的题目：面试题04. 二维数组中的查找 题目描述：在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目描述在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解法一，暴力求解法因为是 n * m 的二维数组，所以我们可以直接使用双层遍历来遍历整个二维数组的项。注意，该方法不管你数组是递增还是递减的规律，直接一梭子遍历就完事了 12345678910111213141516171819202122var findNumberIn2DArray = function(matrix, target) { // 多少行 const rowLength = matrix.length if(!rowLength) return false // 多少列 const colLength = matrix[0].length if(!colLength) return false for(let i = 0; i &lt; rowLength; i++) { for(let j = 0; j &lt; colLength; j++) { if(matrix[i][j] === target) { return true } } } return false}; 当然，我们也可以使用数组提供的 API 去解决这道问题，例如：indexOf，includes，但是由于该种做法过于简单，我们刷题的时候应该尽量避免使用此类 API，下面讲述一下思路： 遍历数组的每一个项，再使用数组的每一项去判断子数组中是否存在目标元素（indexOf 判断子数组中目标元素的位置，可以用是否大于 -1 来判断，includes 则是判断数组中是否存在某元素，存在则返回 true，否则返回 false） 解法二，发现规律从题目描述中可以发现二维数组中的每一行都按照从左到右递增，每一列都按照从上到下递增。我们可以利用这一规律作为解题的突破口，那么 从数组中选取一个数组，分三种情况来分析查找的过程 如果数组中选取的数字刚好等于目标元素，那么直接返回 true，结束查找。 如果选取的数字小于目标元素，那么目标元素的位置应该在选取的数字的右边或者下边 同样，如果选取的数字大于目标元素，那么目标元素的位置应该在选取的数字的左边或者上边 1234567891011121314151617181920212223242526272829var findNumberIn2DArray = function(matrix, target) { const rowLength = matrix.length if(!rowLength) { return false } const colLength = matrix[0].length if(!colLength) { return false } let row = 0, col = colLength - 1; while(row &lt; rowLength &amp;&amp; col &gt;= 0) { if(matrix[row][col] === target) { // 第一种情况 return true } else if(matrix[row][col] &gt; target) { // 第三种情况 --col } else { // 第二种情况 ++row } } return false};","link":"/blog/2020/03/18/剑指offer-javascript版-二维数组中的查找/"},{"title":"剑指Offer-Javascript版-从尾到头打印链表","text":"对应LeetCode上的题目：面试题06. 从尾到头打印链表 题目描述：输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下： 1234function ListNode(val) { this.val = val; this.next = null;} 题目描述输入一个链表的头节点，从尾到头反过来打印出每个节点的值，链表节点定义如下： 1234function ListNode(val) { this.val = val; this.next = null;} 解法一，使用栈不改变链表的前提下。 遍历链表的顺序都是从头到尾，但是输出的顺序是从尾到头，也就是说第一个遍历的节点最后一个输出，最后一个遍历的节点第一个输出。这个不就是后进先出 吗？那么我们可以使用 栈 来实现这种做法。 每经过一个节点的时候，就把该节点放到一个栈中，当遍历完整个链表后。再从栈顶逐个输出节点的值 12345678910111213141516const printReverseListNode = (head) =&gt; { if (!head) return [] // 栈用来存放已经遍历过的数组 const stack = [] let curNode = head while(curNode) { stack.push(curNode.val) curNode = curNode.next } return stack.reverse()} 可见，使用栈来解决这类问题，是非常的简单。但是我们也要熟知栈的各种概念，我们才能在解题的时候游刃有余，一点都不慌。 当然啦，我们也可以使用递归来实现这种解法 1234567891011121314151617const printReverseListNode = (head) =&gt; { if (!head) return [] const stack =[] const getReverseListNode = (head) =&gt; { if(head) { if(head.next !== null) { printReverseListNode(head.next) } stack.push(head.val) } } getReverseListNode(head) return stack}","link":"/blog/2020/03/19/剑指offer-javascript版-从尾到头打印链表/"},{"title":"剑指Offer-Javascript版-找出数组中的数字","text":"对应LeetCode上的题目：面试题03. 数组中重复的数字 题目描述：在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字 题目描述在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字 解法一，暴力求解法先把输入的数字排序，从排序的数字中找出重复的数字，即需要从头到尾扫描排序后的数组就可以了，排序一个长度为 n 的数组需要 O(nlogn) 的时间（排序最快的速度是 O(nlogn) ，即快速排序） 1234567891011const findRepeatNumber = (nums) =&gt; { // 先排序 nums.sort((a, b) =&gt; a - b) for(let i = 0, len = nums.length; i &lt; len-1; i++) { // 比较前后的值是否相同 if(nums[i] === nums[i+1]) { return nums[i] } }} 可想而知，这种解法并不是那么令人满意，因为需要先把数组排序 解法二，使用对象使用对象来解决这个问题，从头到尾遍历整个数组，依次把数组的每一项当作对象的 key 值存进对象。如果数组的某个项在对象中存在，那么我们就可以认为这个值在数组中重复了，直接返回即可 12345678910111213const findRepeatNumber = (nums) =&gt; { // 用来存放是否遍历过的数组的项 const obj = {} for(let i = 0; i &lt; nums.length; i++) { // 数组的项是否已经是对象obj的键值了 if(obj[nums[i]]) { return nums[i] } else { obj[nums[i]] = 1 } }} 解法三，数学分析法从头到尾遍历数组 当数组下标为 i 的时候，比较这个数字（用 m 表示）是不是等于 i，如果是，则接着扫描下一个数字。 如果不是，拿它与第 m 个数字进行比较。如果它和第 m 个数字相等，就找到了一个重复的数组（i 和 m 的位置上都存在数字 m）。如果它和第 m 个数字不相等，就把第 i 个位置上的数字和第 m 个位置上的数字交换，那么 第 m 位上的数字就是 m 了 重复这个比较，直到发现一个重复的数字 [2, 3, 1, 0, 2, 5, 3] 举个例子： 首先遍历这个数组，从 0 位置上开始遍历。0 上面的数字是 2，那么我们可以直接拿数字 2 和 2 位置上的 1 做比较，结果不相等，交换位置。交换之后的数组是 [1, 3, 2, 0, 2, 5, 3] 此时 0 位置上面的数字是 1，仍然不相等，继续和下标为 1 的 数字 3 做交换。交换之后的数组是 [3, 1, 2, 0, 2, 5, 3] 此时 0 位置上面的数字是 3，仍然不相等，继续和下标为 3 的 数字 0 做交换。交换之后的数组是 [0, 1, 2, 3, 2, 5, 3] 这时候 0 位置上的数字是 0 了，那么我们可以直接遍历下一个数字了，可知接下来的数字 1，2，3 都与坐标相等，不用进行交换操作。 接下来到位置 4 的数字 2 ，由于数字与位置不相等，再比较位置 2 上的数字。发现位置 2 上的数字也是 2 了，因此我们便找到了一个重复的数字 123456789101112131415const findRepeatNumber = (nums) =&gt; { for(let i = 0; i &lt; nums.length; i++) { while(nums[i] !== i) { if(nums[i] === nums[nums[i]]) { return nums[i] } // 交换数组两个位置上的项，这里是i 和 num[i] 交换 let temp= nums[i] nums[i] = nums[temp] nums[temp] = temp } }}","link":"/blog/2020/03/17/剑指offer-javascript版-找出数组中的数字/"},{"title":"剑指Offer-Javascript版-重建二叉树","text":"对应LeetCode上的题目：面试题07. 重建二叉树 题目描述：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例子 1234567891011给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 解法：二叉树的前序遍历和中序遍历二叉树的前序遍历中，第一个数字是二叉树的根节点。在中序遍历中，根节点位于序列的中间，即根节点的左边是左子树节点的值，右边是右子树节点的值。 由前序遍历 [3,9,20,15,7] 可知，3 是根节点。中序遍历 [9,3,15,20,7] 可知，根节点 3 的左边是左子树节点 9，右边是右子树节点 15，20，7。所以 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */var buildTree = function(preorder, inorder) { if(!preorder.length || !inorder.length) { return null } const rootVal = preorder[0] const node = new TreeNode(rootVal) // i有两个含义，一个是根节点在中序遍历结果中的下标， 另一个是当前左子树的节点个数 let i = 0; for(; i &lt; inorder.length; ++i) { if(inorder[i] === rootVal) { break; } } // i主要是求出根节点在中序遍历序列中的位置。那么i位置前面的都是左子树的值，后边的都是右子树的值。 // 中序遍历和前序遍历的左子树和右子树节点的个数都分别相等 node.left = buildTree(preorder.slice(1, i+1), inorder.slice(0, i)) node.right = buildTree(preorder.slice(i+1), inorder.slice(i + 1)) return node}; 知识扩展","link":"/blog/2020/03/19/剑指offer-javascript版-重建二叉树/"},{"title":"剑指Offer-Javascript版-替换空格","text":"对应LeetCode上的题目：面试题05. 替换空格 题目描述：请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 例： 12输入：s = \"We are happy.\"输出：\"We%20are%20happy.\" 题目描述请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 例： 12输入：s = \"We are happy.\"输出：\"We%20are%20happy.\" 解法一，正则表达式字符串有一个 replace 方法，可以把字符串里面特定的字符转换成我们想要的字符 123456var replaceSpace = function(s) { if(!s) return return s.replace(/ /g, '%20')}; 一句代码就搞定，这方法真香 解法二使用字符串的分割 split 和 数组的分割 join 123456var replaceSpace = function(s) { if(!s) return return s.spilt(' ').join('%20')}; 注意，虽然这种 api 是香，但是只能作为一种辅助的方法，面试官更多想考我们的算法能力和解题思路，这种只能用来当作题目的一种解法 解法三，双指针遍历原字符串，统计空格和非空格字符个数，计算替换后的新字符的长度，准备两个指针，指针 i 指向原字符串，指针 j 指向新字符串 123456789101112131415161718192021222324252627282930313233var replaceSpace = function(s) { if(!s || !s.length) { return \"\" } // emptyNum 空格的个数 // chNum 非空字符的个数 let emptyNum = 0, chNum = 0; for(let i = 0, len = s.length; i &lt; len; i++) { if(s[i] === ' ') { ++emptyNum } else { ++chNum } } const length = emptyNum * 2 + chNum const chs = new Array(length) // i 是新字符串的下标，j是源字符串的下标 for(let i = 0, j = 0; j &lt; s.length; ++j) { if(s[j] === \" \") { chs[i++] = \"%\" chs[i++] = \"2\" chs[i++] = \"0\" } else { chs[i++] = s[j] } } return chs.join(\"\")}","link":"/blog/2020/03/18/剑指offer-javascript版-替换空格/"},{"title":"树","text":"想普及一下树的知识，个人认为树是算法必须要牢牢掌握的一部分。 一般树的逻辑可以说是灰常滴简单了： 除根节点之外的每个节点只有一个父节点，根节点没有父节点。 除叶节点之外所有节点都有一个或多个子节点，叶节点没有子节点。 父节点和子节点之间是用指针连接，所以树会涉及到大量的指针，因此与树有关的面试题都不太容易，但是越不容易的知识点，我们就越要攻克。 树的遍历但是面试时候提到的树，大部分都是二叉树。二叉树是树的一种特殊结构，在二叉树中每个节点最多只能有两个子节点。在二叉树中最重要的考点莫过于树的遍历，即按照某一个顺序遍历访问树中的所有节点。 二叉树的遍历可以有以下几种： 前序遍历 前序遍历：先访问根节点，再访问左节点，最后访问右节点 12345678910111213141516171819202122232425262728293031323334353637383940414243// 递归版本const preOrderTraverse = (root) =&gt; { let list = [] const preOrder = (node) =&gt; { if(node !== null) { // 先访问根节点 list.push(node.val) // 再访问左节点 preOrder(node.left) // 最后访问右节点 preOrder(node.right) } } inOrder(root) return list}// 非递归版本const preOrderTraverseUnRecur = (root) =&gt; { let list = []; let stack = [root]; while(stack.length !== 0) { const curNode = stack.pop() const left = curNode.left const right = curNode.right // 第一步的时候，先访问的是根节点 list.push(curNode.val) if(right) { stack.push(right) } // 因为pop是取出最后一个元素，所以我们要确保首先拿到的是左节点 if(left) { stack.push(left) } }} 中序遍历 中序遍历：先访问左节点，再访问中节点，最后访问右节点 123456789101112131415161718192021222324252627282930313233343536373839// 递归版本const inOrderTraverse = (root) =&gt; { let list = [] const inOrder = (node) =&gt; { if(node !== null) { inOrder(node.left) list.push(node.val) inOrder(node.right) } } inOrder(root) return list}// 非递归版本const inOrderTraverseUnRecur = (root) =&gt; { let list = [] // 借助了栈，先进后出的概念 let stack = [] let head = root while(stack.length !== 0 || head !== undefined) { while(head !== undefined) { stack.push(head) head = head.left } if(stack.length !== 0) { head = stack.pop() list.push(head.val) head = head.right } } return list} 后序遍历 后序遍历：先访问左节点，再访问右节点，最后访问根节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 递归const postOrderTraverse = (root) =&gt; { let list = [] const postOrder = (node) =&gt; { if(!node) { postOrder(node.left) postOrder(node.right) list.push(node.val) } } postOrder(root) return list}// 非递归const postOrderTraverseUnRecur = (root) =&gt; { let list = [] if(root !== undefined) { let s1 = [] let s2 = [] s1.push(root) while(s1.length !== 0) { head = s1.pop() s2.push(head) if(head.left !== undefined) { s1.push(head.left) } if(head.right !== undefined) { s1.push(head.right) } } while(s2.length !== 0) { var item = s2.pop() list.push(item.val) } } return list} 为了方便记忆，可以这样记：前序遍历对应的前是根节点最先访问。中序遍历对应的前是根节点放在中间访问。后序遍历对应的前是根节点最后才访问。 这三种遍历方式都有 递归 和 循环 两种不同的实现方式，但是面试官更喜欢考我们的是循环实现方式，所以我们应该要掌握这三种遍历的六种遍历方式! 广度优先遍历 广度优先遍历：即先访问树的第一层节点，接着访问第二层节点…一直访问到最后一层节点 深度优先遍历 深度优先遍历：即先访问树的根节点，再访问根节点的子节点，先往深层访问，深层访问节点结束了，再返回访问同层节点，之后再继续往深层访问节点… 二叉搜索树二叉搜索树：左子节点总是小于或等于根节点，而右节点总是大于或等于根节点。可以在 O(logn) 内根据数值在二叉搜索树中找到一个节点 堆堆：分为最大堆和最小堆。最大堆中根节点的值最大，在最小堆中根节点的值最小。需要快速找到最大值或最小值都可以用堆来解决 红黑树红黑树：把树中的节点定义为红，黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度不超过最短路径的两倍","link":"/blog/2020/03/21/树的遍历/"},{"title":"如何理解Javascript中的this","text":"关于this指向的文章，网上一搜一大把，可是很多文章都是复制粘贴的水文，是否真正的了解JavaScript中的this，那就未必。那么我们应该如何简单轻松的理解this呢？ 要简单轻松的理解this，就要记住一句话：this的指向并不是在函数定义的时候确定的，而是在其被调用的时候确定的。也就是说，this是在运行的时候基于函数的执行环境绑定的。 this的指向可以分为5大类： 纯粹的函数调用 作为对象的属性调用 作为构造函数调用 apply,call调用 箭头函数调用 一、 纯粹的函数调用 纯粹的函数调用，也就是最普遍的函数调用方式。非严格模式下，this指向的是window。严格模式下，this指向了undefined。 1234567891011121314151617// 非严格模式下var a = 10; // 全局变量相当于在window上面挂载属性a，window.afunction func() { &quot;use strict&quot;; console.log(this.a);}func(); // 10// 严格模式下var b = 10;function func1() { &quot;use strict&quot;; console.log(this.b);}func1(); // Uncaught TypeError: Cannot read property &apos;b&apos; of undefined 二、作为对象的属性调用函数作为对象的属性调用时候，this 指向这个对象。（实际上纯粹的函数调用也可以算是作为对象的函数调用，因为全局变量是直接挂载在window上的，所以 func() 也就相当于 window.func() ） 1234567891011var a = 20;var obj = { a: 10, func: func}function func() { console.log(this.a);}obj.func() // this指向了obj，所以this.a会打印出10 要注意的是，如果像下面这种情况，this 指向的是window的 12345678910111213var a = 20;var obj = { a: 10, func: func}function func() { console.log(this.a);}var func1 = obj.funcfunc1() // 20, this指向了window 所以说还得看函数调用的位置。 三、作为构造函数调用通过构造函数，可以生成一个新对象（这个也就是我们经常说的实例）。这时，this就指这个新对象。 123456function Func() { this.a = 10;}var obj = new Func()console.log(obj.a); // 10 使用new调用构造函数实际上会经历四个过程： 创建一个新对象 将构造函数的作用域赋给新对象。（this指向了新对象） 执行构造函数中的代码。（挂载属性） 返回新的对象 如何手动实现new的功能？ 123456789101112131415161718192021222324function create() { // 创建一个新的对象 var obj = new Object(), // 获得构造函数，arguments中去除第一个参数，Func指的是构造函数 Func = [].shift.call(arguments); // 将构造函数的作用域赋给新对象。 obj.__proto__ = Func.prototype; // 执行构造函数中的代码，使obj 可以访问到构造函数中的属性 var res = Func.apply(obj, arguments); // 返回新的对象。判断构造函数的返回值是否是对象，如果是就返回。不是就返回新的对象。 return res instanceof Object ? res : obj;};function Func() { this.a = 20;}// 使用newvar func1 = new Func() // 使用手写的new，即createvar func2 = create(Func)console.log(func1, func2); // {a: 20}, {a: 20} 四、apply、call调用apply、call都是是函数的一个方法，作用是改变函数的调用对象。它们的第一个参数就表示改变后的调用这个函数的对象。this 指的就是这第一个参数。 123456789var obj = { a: 20}function func() { console.log(this.a);}func.call(obj); // 20func.apply(obj); // 20 不同的是，apply的第二个参数是一个数组或者类数组对象，而call的是指定的参数列表。 五、箭头函数调用箭头函数有两个作用，更简短的函数并且不绑定this。即箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承 this 。简单点来说，箭头函数的 this 会继承外层不为箭头函数的函数的 this 123456789var a = 20;function func() { var fun1 = () =&gt; { console.log(this.a) } return fun1}func()(); // 20，箭头函数fun1的this会从外层不为箭头函数的函数func继承而来。func的this指向了window，所以this.a是20","link":"/blog/2020/03/17/如何理解javascript中的this/"},{"title":"强缓存和协商缓存","text":"之前一直对浏览器缓存只能描述一个大概，深层次的原理不能描述上来；为了泄恨，查阅一些资料最终对其有了一个更深入的理解 本文主要讲解浏览器端的缓存，缓存的作用是不言而喻的，能够极大的改善网页性能，提高用户体验。 浏览器缓存的基本认识分为强缓存 和 协商缓存 （1）浏览器在加载资源的时候，会根据HTTP的头部header判断它是否命中强缓存，强缓存如果直接命中，那么浏览器就会直接从自己的缓存中读取资源，而不会请求到服务器。比如某个css文件，如果浏览器在加载这个文件的时候，从这个文件的http头部判断命中了缓存，那么就会直接从内存中读取这个css文件，而不会再去请求服务器。 （2）当强缓存没有命中的时候，那么浏览器就会发送http请求到服务器，通过服务器依据资源的另外一些http头部去验证这个资源是否命中协商缓存，如果协商缓存命中，服务器就将这个请求返回，但是并不会返回这个资源的数据，而是告诉浏览器可以直接从缓存中读取这个资源，那么浏览器就会从缓存中读取这个资源。 （3）强缓存和协商缓存的共同点：如果命中，那么都会从客户端的缓存中去读取资源，而不是从服务器中读取资源。不同的是，强缓存不会发送请求到服务器，而协商缓存则需要发送请求到服务器。 （4）如果协商缓存也没有命中的时候，浏览器直接从服务器中加载资源数据。 强缓存当浏览器对某个资源的请求命中了强缓存时，返回的 http 状态为200，在 chrome 的开发者工具的 network 里面 size 会显示为 from cache。 强缓存是利用 Expires 或者 Cache-Control 这两个 http response header 实现的，它们都用来表示资源在客户端缓存的有效期。 一，ExpiresExpires 是 http1.0 提出的一个表示资源过期时间的 header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是： （1）浏览器第一次跟服务器请求一个资源的时候，服务器在返回这个资源的同时，会在 response 的 header 加上 Expires 的 header，如 （2）浏览器在接收到这个资源后，会把这个资源连同所有的 response header 一起缓存下来（所有缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header） （3）浏览器再请求这个资源的时候，会先从缓存中去寻找，最好找到这个资源后，会拿当前的时间和Expire设置的时间比较，如果当前请求的时间在 Expires 指定的时间之前，那么就能命中缓存，否则不命中。 （4）如果缓存没有命中，那么浏览器直接从服务器中加载资源时，Expire Header 在重新加载的时候就会被更新。 弊端：Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。 所以在 HTTP1.1 的时候，就提出了一个新的header：Cache-Control，这是一个相对的时间，在配置缓存的时候以秒为单位，用数值表示，如：Cache-Control：max-age=315360000 二，Cache-Control（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header，如： （2）浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来； （3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。（4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。 Cache-Control 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。这两个header可以只启用一个，也可以同时启用，当response header 中，Expires 和 Cache-Control 同时存在时，Cache-Control 优先级高于Expires： 协商缓存当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看 network，可以看到有不少请求就是命中了协商缓存的： 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的 一，【Last-Modified，If-Modified-Since】（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上 Last-Modified 的header，这个header表示这个资源在服务器上的最后修改时间： （2）浏览器再次跟服务器请求这个资源时，在request的header上加上 If-Modified-Since 的header，这个header的值就是上一次请求时返回的Last-Modified的值： （3）服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加 Last-Modified的header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回304时的 `response header ： （4）浏览器收到304的响应后，就会从缓存中加载资源。（5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-ModifiedHeader在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。 弊端：【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。 所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。 二，【ETag、If-None-Match】（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题： （2）浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值： （3）服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化： （4）浏览器收到304的响应后，就会从缓存中加载资源。","link":"/blog/2020/03/18/浏览器缓存/"}],"tags":[{"name":"数组","slug":"数组","link":"/blog/tags/数组/"},{"name":"链表","slug":"链表","link":"/blog/tags/链表/"},{"name":"栈","slug":"栈","link":"/blog/tags/栈/"},{"name":"二叉树","slug":"二叉树","link":"/blog/tags/二叉树/"},{"name":"树","slug":"树","link":"/blog/tags/树/"},{"name":"字符串","slug":"字符串","link":"/blog/tags/字符串/"},{"name":"javascript","slug":"javascript","link":"/blog/tags/javascript/"},{"name":"http","slug":"http","link":"/blog/tags/http/"},{"name":"缓存","slug":"缓存","link":"/blog/tags/缓存/"}],"categories":[{"name":"算法","slug":"算法","link":"/blog/categories/算法/"},{"name":"javascript","slug":"javascript","link":"/blog/categories/javascript/"},{"name":"http","slug":"http","link":"/blog/categories/http/"}]}